// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2024, WSO2 LLC. (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/http;

# Zendesk Support API endpoints
public isolated client class Client {
    final http:Client clientEp;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector`
    # + serviceUrl - URL of the target service
    # + return - An error if connector initialization failed
    public isolated function init(ConnectionConfig config, string serviceUrl = "https://example.zendesk.com") returns error? {
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, timeout: config.timeout, forwarded: config.forwarded, poolConfig: config.poolConfig, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, validation: config.validation};
        do {
            if config.http1Settings is ClientHttp1Settings {
                ClientHttp1Settings settings = check config.http1Settings.ensureType(ClientHttp1Settings);
                httpClientConfig.http1Settings = {...settings};
            }
            if config.http2Settings is http:ClientHttp2Settings {
                httpClientConfig.http2Settings = check config.http2Settings.ensureType(http:ClientHttp2Settings);
            }
            if config.cache is http:CacheConfig {
                httpClientConfig.cache = check config.cache.ensureType(http:CacheConfig);
            }
            if config.responseLimits is http:ResponseLimitConfigs {
                httpClientConfig.responseLimits = check config.responseLimits.ensureType(http:ResponseLimitConfigs);
            }
            if config.secureSocket is http:ClientSecureSocket {
                httpClientConfig.secureSocket = check config.secureSocket.ensureType(http:ClientSecureSocket);
            }
            if config.proxy is http:ProxyConfig {
                httpClientConfig.proxy = check config.proxy.ensureType(http:ProxyConfig);
            }
        }
        http:Client httpEp = check new (serviceUrl, httpClientConfig);
        self.clientEp = httpEp;
        return;
    }
    # List assignable groups and agents based on query matched against name
    #
    # + name - Query string used to search assignable groups & agents in the AssigneeField
    # + return - Success response
    resource isolated function get api/lotus/assignables/autocomplete\.json(string name, string accept = "application/json") returns AssigneeFieldAssignableGroupsAndAgentsSearchResponse|error {
        string resourcePath = string `/api/lotus/assignables/autocomplete.json`;
        map<anydata> queryParam = {"name": name};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        AssigneeFieldAssignableGroupsAndAgentsSearchResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List assignable groups on the AssigneeField
    #
    # + return - Success response
    resource isolated function get api/lotus/assignables/groups\.json() returns AssigneeFieldAssignableGroupsResponse|error {
        string resourcePath = string `/api/lotus/assignables/groups.json`;
        AssigneeFieldAssignableGroupsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List assignable agents from a group on the AssigneeField
    #
    # + group_id - The ID of the group
    # + return - Success response
    resource isolated function get api/lotus/assignables/groups/[int group_id]/agents\.json(string accept = "application/json") returns AssigneeFieldAssignableGroupAgentsResponse|error {
        string resourcePath = string `/api/lotus/assignables/groups/${getEncodedUri(group_id)}/agents.json`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        AssigneeFieldAssignableGroupAgentsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Get sources by target
    #
    # + target_type - The type of object the relationship field is targeting.
    # The options are "zen:user", "zen:ticket", "zen:organization", and "zen:custom_object:CUSTOM_OBJECT_KEY"
    # + target_id - The id of the object the relationship field is targeting
    # + field_id - The id of the lookup relationship field
    # + source_type - The type of object the relationship field belongs to (example. ticket field belongs to a ticket object).
    # The options are "zen:user", "zen:ticket", "zen:organization", and "zen:custom_object:CUSTOM_OBJECT_KEY"
    # + return - Success response
    resource isolated function get api/v2/[string target_type]/[int target_id]/relationship_fields/[int field_id]/[string source_type](string accept = "application/json") returns ReverseLookupResponse|error {
        string resourcePath = string `/api/v2/${getEncodedUri(target_type)}/${getEncodedUri(target_id)}/relationship_fields/${getEncodedUri(field_id)}/${getEncodedUri(source_type)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ReverseLookupResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Show Settings
    #
    # + return - Success response
    resource isolated function get api/v2/account/settings() returns AccountSettingsResponse|error {
        string resourcePath = string `/api/v2/account/settings`;
        AccountSettingsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Update Account Settings
    #
    # + return - Success response
    resource isolated function put api/v2/account/settings() returns AccountSettingsResponse|error {
        string resourcePath = string `/api/v2/account/settings`;
        http:Request request = new;
        AccountSettingsResponse response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Create Trial Account
    #
    # + return - Created response
    resource isolated function post api/v2/accounts() returns TrialAccountResponse|error {
        string resourcePath = string `/api/v2/accounts`;
        http:Request request = new;
        TrialAccountResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Verify Subdomain Availability
    #
    # + subdomain - Specify the name of the subdomain you want to verify. The name can't contain underscores, hyphens, or spaces.
    # + return - Success response
    resource isolated function get api/v2/accounts/available(string subdomain, string accept = "application/json") returns Inline_response_200|error {
        string resourcePath = string `/api/v2/accounts/available`;
        map<anydata> queryParam = {"subdomain": subdomain};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Inline_response_200 response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Activities
    #
    # + since - A UTC time in ISO 8601 format to return ticket activities since said date.
    # + return - Success response
    resource isolated function get api/v2/activities(string accept = "application/json", string? since = ()) returns ActivitiesResponse|error {
        string resourcePath = string `/api/v2/activities`;
        map<anydata> queryParam = {"since": since};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ActivitiesResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Show Activity
    #
    # + activity_id - The activity ID
    # + return - Success response
    resource isolated function get api/v2/activities/[int activity_id](string accept = "application/json") returns ActivityResponse|error {
        string resourcePath = string `/api/v2/activities/${getEncodedUri(activity_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ActivityResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Count Activities
    #
    # + return - Count of ticket activities
    resource isolated function get api/v2/activities/count() returns ActivitiesCountResponse|error {
        string resourcePath = string `/api/v2/activities/count`;
        ActivitiesCountResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Report Channelback Error to Zendesk
    #
    # + return - Success response
    resource isolated function post api/v2/any_channel/channelback/report_error() returns string|error {
        string resourcePath = string `/api/v2/any_channel/channelback/report_error`;
        http:Request request = new;
        string response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Push Content to Support
    #
    # + return - Success response
    resource isolated function post api/v2/any_channel/push() returns ChannelFrameworkPushResultsResponse|error {
        string resourcePath = string `/api/v2/any_channel/push`;
        http:Request request = new;
        ChannelFrameworkPushResultsResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Validate Token
    #
    # + return - Success response
    resource isolated function post api/v2/any_channel/validate_token() returns string|error {
        string resourcePath = string `/api/v2/any_channel/validate_token`;
        http:Request request = new;
        string response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Attachment
    #
    # + attachment_id - The ID of the attachment
    # + return - Success Response
    resource isolated function get api/v2/attachments/[int attachment_id](string accept = "application/json") returns AttachmentResponse|error {
        string resourcePath = string `/api/v2/attachments/${getEncodedUri(attachment_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        AttachmentResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Attachment for Malware
    #
    # + attachment_id - The ID of the attachment
    # + return - Success response
    resource isolated function put api/v2/attachments/[int attachment_id](AttachmentUpdateRequest payload, string accept = "application/json") returns AttachmentResponse|error {
        string resourcePath = string `/api/v2/attachments/${getEncodedUri(attachment_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        AttachmentResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # List Audit Logs
    #
    # + filterSource_type - Filter audit logs by the source type. For example, user or rule
    # + filterSource_id - Filter audit logs by the source id. Requires `filter[source_type]` to also be set
    # + filterActor_id - Filter audit logs by the actor id
    # + filterIp_address - Filter audit logs by the ip address
    # + filterCreated_at - Filter audit logs by the time of creation. When used, you must specify `filter[created_at]` twice in your request, first with the start time and again with an end time
    # + filterAction - Filter audit logs by the action
    # + sort_by - Offset pagination only. Sort audit logs. Default is `sort_by=created_at`
    # + sort_order - Offset pagination only. Sort audit logs. Default is `sort_order=desc`
    # + sort - Cursor pagination only. Sort audit logs. Default is `sort=-created_at`
    # + return - Success response
    resource isolated function get api/v2/audit_logs(string accept = "application/json", string? filterSource_type = (), int? filterSource_id = (), int? filterActor_id = (), string? filterIp_address = (), string? filterCreated_at = (), string? filterAction = (), string? sort_by = (), string? sort_order = (), string? sort = ()) returns AuditLogsResponse|error {
        string resourcePath = string `/api/v2/audit_logs`;
        map<anydata> queryParam = {"filter[source_type]": filterSource_type, "filter[source_id]": filterSource_id, "filter[actor_id]": filterActor_id, "filter[ip_address]": filterIp_address, "filter[created_at]": filterCreated_at, "filter[action]": filterAction, "sort_by": sort_by, "sort_order": sort_order, "sort": sort};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        AuditLogsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Show Audit Log
    #
    # + audit_log_id - The ID of the audit log
    # + return - Success response
    resource isolated function get api/v2/audit_logs/[int audit_log_id](string accept = "application/json") returns AuditLogResponse|error {
        string resourcePath = string `/api/v2/audit_logs/${getEncodedUri(audit_log_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        AuditLogResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Export Audit Logs
    #
    # + filterSource_type - Filter audit logs by the source type. For example, user or rule
    # + filterSource_id - Filter audit logs by the source id. Requires `filter[source_type]` to also be set.
    # + filterActor_id - Filter audit logs by the actor id
    # + filterIp_address - Filter audit logs by the ip address
    # + filterCreated_at - Filter audit logs by the time of creation. When used, you must specify `filter[created_at]` twice in your request, first with the start time and again with an end time
    # + filterAction - Filter audit logs by the action
    # + return - Accepted description
    resource isolated function post api/v2/audit_logs/export(string accept = "application/json", string? filterSource_type = (), int? filterSource_id = (), int? filterActor_id = (), string? filterIp_address = (), string? filterCreated_at = (), string? filterAction = ()) returns string|error {
        string resourcePath = string `/api/v2/audit_logs/export`;
        map<anydata> queryParam = {"filter[source_type]": filterSource_type, "filter[source_id]": filterSource_id, "filter[actor_id]": filterActor_id, "filter[ip_address]": filterIp_address, "filter[created_at]": filterCreated_at, "filter[action]": filterAction};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        string response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Search Tags
    #
    # + name - A substring of a tag to search for
    # + return - Success response
    resource isolated function get api/v2/autocomplete/tags(string accept = "application/json", string? name = ()) returns TagsByObjectIdResponse|error {
        string resourcePath = string `/api/v2/autocomplete/tags`;
        map<anydata> queryParam = {"name": name};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TagsByObjectIdResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Automations
    #
    # + return - Success response
    resource isolated function get api/v2/automations() returns AutomationsResponse|error {
        string resourcePath = string `/api/v2/automations`;
        AutomationsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Automation
    #
    # + return - Created response
    resource isolated function post api/v2/automations() returns AutomationResponse|error {
        string resourcePath = string `/api/v2/automations`;
        http:Request request = new;
        AutomationResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Automation
    #
    # + automation_id - The ID of the automation
    # + return - Success response
    resource isolated function get api/v2/automations/[int automation_id](string accept = "application/json") returns AutomationResponse|error {
        string resourcePath = string `/api/v2/automations/${getEncodedUri(automation_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        AutomationResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Automation
    #
    # + automation_id - The ID of the automation
    # + return - Success response
    resource isolated function put api/v2/automations/[int automation_id](string accept = "application/json") returns AutomationResponse|error {
        string resourcePath = string `/api/v2/automations/${getEncodedUri(automation_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        AutomationResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Automation
    #
    # + automation_id - The ID of the automation
    # + return - No Content response
    resource isolated function delete api/v2/automations/[int automation_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/automations/${getEncodedUri(automation_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # List Active Automations
    #
    # + return - Success response
    resource isolated function get api/v2/automations/active() returns AutomationsResponse|error {
        string resourcePath = string `/api/v2/automations/active`;
        AutomationsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Bulk Delete Automations
    #
    # + ids - The IDs of the automations to delete
    # + return - No Content response
    resource isolated function delete api/v2/automations/destroy_many(string accept = "application/json", int[]? ids = ()) returns error? {
        string resourcePath = string `/api/v2/automations/destroy_many`;
        map<anydata> queryParam = {"ids": ids};
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam, queryParamEncoding);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Search Automations
    #
    # + query - Query string used to find all automations with matching title
    # + active - Filter by active automations if true or inactive automations if false
    # + sort_by - Possible values are "alphabetical", "created_at", "updated_at", and "position". If unspecified, the automations are sorted by relevance
    # + sort_order - One of "asc" or "desc". Defaults to "asc" for alphabetical and position sort, "desc" for all others
    # + include - A sideload to include in the response. See [Sideloads](#sideloads-2)
    # + return - Success response
    resource isolated function get api/v2/automations/search(string query, string accept = "application/json", boolean? active = (), string? sort_by = (), string? sort_order = (), string? include = ()) returns AutomationsResponse|error {
        string resourcePath = string `/api/v2/automations/search`;
        map<anydata> queryParam = {"query": query, "active": active, "sort_by": sort_by, "sort_order": sort_order, "include": include};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        AutomationsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Many Automations
    #
    # + return - Success response
    resource isolated function put api/v2/automations/update_many() returns AutomationsResponse|error {
        string resourcePath = string `/api/v2/automations/update_many`;
        http:Request request = new;
        AutomationsResponse response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # List Bookmarks
    #
    # + return - Successful response
    resource isolated function get api/v2/bookmarks() returns BookmarksResponse|error {
        string resourcePath = string `/api/v2/bookmarks`;
        BookmarksResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Bookmark
    #
    # + return - Successfully created
    resource isolated function post api/v2/bookmarks(BookmarkCreateRequest payload) returns BookmarkResponse|error {
        string resourcePath = string `/api/v2/bookmarks`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        BookmarkResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Delete Bookmark
    #
    # + bookmark_id - The ID of the bookmark
    # + return - No content
    resource isolated function delete api/v2/bookmarks/[int bookmark_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/bookmarks/${getEncodedUri(bookmark_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # List Brands
    #
    # + return - Successful response
    resource isolated function get api/v2/brands() returns BrandsResponse|error {
        string resourcePath = string `/api/v2/brands`;
        BrandsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Brand
    #
    # + return - Successful response
    resource isolated function post api/v2/brands(BrandCreateRequest payload) returns BrandResponse|error {
        string resourcePath = string `/api/v2/brands`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        BrandResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show a Brand
    #
    # + brand_id - The ID of the brand
    # + return - Successful response
    resource isolated function get api/v2/brands/[int brand_id](string accept = "application/json") returns BrandResponse|error {
        string resourcePath = string `/api/v2/brands/${getEncodedUri(brand_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        BrandResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update a Brand
    #
    # + brand_id - The ID of the brand
    # + return - Successful response
    resource isolated function put api/v2/brands/[int brand_id](BrandUpdateRequest payload, string accept = "application/json") returns BrandResponse|error {
        string resourcePath = string `/api/v2/brands/${getEncodedUri(brand_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        BrandResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete a Brand
    #
    # + brand_id - The ID of the brand
    # + return - No Content response
    resource isolated function delete api/v2/brands/[int brand_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/brands/${getEncodedUri(brand_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Check Host Mapping Validity for an Existing Brand
    #
    # + brand_id - The ID of the brand
    # + return - Successful response
    resource isolated function get api/v2/brands/[int brand_id]/check_host_mapping(string accept = "application/json") returns HostMappingObject|error {
        string resourcePath = string `/api/v2/brands/${getEncodedUri(brand_id)}/check_host_mapping`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        HostMappingObject response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Check Host Mapping Validity
    #
    # + host_mapping - The hostmapping to a brand, if any (only admins view this key)
    # + subdomain - Subdomain for a given Zendesk account address
    # + return - Successful response
    resource isolated function get api/v2/brands/check_host_mapping(string host_mapping, string subdomain, string accept = "application/json") returns HostMappingObject|error {
        string resourcePath = string `/api/v2/brands/check_host_mapping`;
        map<anydata> queryParam = {"host_mapping": host_mapping, "subdomain": subdomain};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        HostMappingObject response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Monitored Twitter Handles
    #
    # + return - Success response
    resource isolated function get api/v2/channels/twitter/monitored_twitter_handles() returns TwitterChannelsResponse|error {
        string resourcePath = string `/api/v2/channels/twitter/monitored_twitter_handles`;
        TwitterChannelsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Show Monitored Twitter Handle
    #
    # + monitored_twitter_handle_id - The ID of the custom agent role
    # + return - Success response
    resource isolated function get api/v2/channels/twitter/monitored_twitter_handles/[int monitored_twitter_handle_id](string accept = "application/json") returns TwitterChannelResponse|error {
        string resourcePath = string `/api/v2/channels/twitter/monitored_twitter_handles/${getEncodedUri(monitored_twitter_handle_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TwitterChannelResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Ticket from Tweet
    #
    # + return - description
    resource isolated function post api/v2/channels/twitter/tickets() returns string|error {
        string resourcePath = string `/api/v2/channels/twitter/tickets`;
        http:Request request = new;
        string response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # List Twicket statuses
    #
    # + comment_id - The ID of the comment
    # + ids - Optional comment ids to retrieve tweet information for only particular comments
    # + return - Success response
    resource isolated function get api/v2/channels/twitter/tickets/[int comment_id]/statuses(string accept = "application/json", string? ids = ()) returns TwitterChannelTwicketStatusResponse|error {
        string resourcePath = string `/api/v2/channels/twitter/tickets/${getEncodedUri(comment_id)}/statuses`;
        map<anydata> queryParam = {"ids": ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TwitterChannelTwicketStatusResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Open Ticket in Agent's Browser
    #
    # + agent_id - ID of an agent
    # + ticket_id - The ID of the ticket
    # + return - Successful response
    resource isolated function post api/v2/channels/voice/agents/[int agent_id]/tickets/[int ticket_id]/display(string accept = "application/json") returns string|error {
        string resourcePath = string `/api/v2/channels/voice/agents/${getEncodedUri(agent_id)}/tickets/${getEncodedUri(ticket_id)}/display`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        string response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Open a User's Profile in an Agent's Browser
    #
    # + agent_id - ID of an agent
    # + user_id - The id of the user
    # + return - Successful response
    resource isolated function post api/v2/channels/voice/agents/[int agent_id]/users/[int user_id]/display(string accept = "application/json") returns string|error {
        string resourcePath = string `/api/v2/channels/voice/agents/${getEncodedUri(agent_id)}/users/${getEncodedUri(user_id)}/display`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        string response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Create Ticket or Voicemail Ticket
    #
    # + agent_id - ID of an agent
    # + ticket_id - The ID of the ticket
    # + return - Successful response
    resource isolated function post api/v2/channels/voice/tickets(TicketCreateVoicemailTicketRequest payload, string accept = "application/json") returns TicketResponse|error {
        string resourcePath = string `/api/v2/channels/voice/tickets`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        TicketResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Redact Chat Comment Attachment
    #
    # + ticket_id - The ID of the ticket
    # + return - Success response
    resource isolated function put api/v2/chat_file_redactions/[int ticket_id](string accept = "application/json") returns TicketChatCommentRedactionResponse|error {
        string resourcePath = string `/api/v2/chat_file_redactions/${getEncodedUri(ticket_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        TicketChatCommentRedactionResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Redact Chat Comment
    #
    # + ticket_id - The ID of the ticket
    # + return - Success response
    resource isolated function put api/v2/chat_redactions/[int ticket_id](string accept = "application/json") returns TicketChatCommentRedactionResponse|error {
        string resourcePath = string `/api/v2/chat_redactions/${getEncodedUri(ticket_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        TicketChatCommentRedactionResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Redact Ticket Comment In Agent Workspace
    #
    # + ticket_comment_id - The ID of the ticket comment
    # + return - Success response
    resource isolated function put api/v2/comment_redactions/[int ticket_comment_id](string accept = "application/json") returns TicketCommentResponse|error {
        string resourcePath = string `/api/v2/comment_redactions/${getEncodedUri(ticket_comment_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        TicketCommentResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # List Custom Objects
    #
    # + return - Success response
    resource isolated function get api/v2/custom_objects() returns CustomObjectsResponse|error {
        string resourcePath = string `/api/v2/custom_objects`;
        CustomObjectsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Custom Object
    #
    # + return - Created
    resource isolated function post api/v2/custom_objects(CustomObjectsCreateRequest payload) returns CustomObjectResponse|error {
        string resourcePath = string `/api/v2/custom_objects`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        CustomObjectResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Custom Object
    #
    # + custom_object_key - The key of a custom object
    # + return - Custom Object
    resource isolated function get api/v2/custom_objects/[string custom_object_key](string accept = "application/json") returns CustomObjectResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CustomObjectResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Delete Custom Object
    #
    # + custom_object_key - The key of a custom object
    # + return - No content response
    resource isolated function delete api/v2/custom_objects/[string custom_object_key](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Update Custom Object
    #
    # + custom_object_key - The key of a custom object
    # + return - Success response
    resource isolated function patch api/v2/custom_objects/[string custom_object_key](string accept = "application/json") returns CustomObjectResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        CustomObjectResponse response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # List Custom Object Fields
    #
    # + custom_object_key - The key of a custom object
    # + include_standard_fields - Include standard fields if true. Exclude them if false
    # + return - Success response
    resource isolated function get api/v2/custom_objects/[string custom_object_key]/fields(string accept = "application/json", boolean? include_standard_fields = ()) returns CustomObjectFieldsResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/fields`;
        map<anydata> queryParam = {"include_standard_fields": include_standard_fields};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CustomObjectFieldsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Custom Object Field
    #
    # + custom_object_key - The key of a custom object
    # + return - Created
    resource isolated function post api/v2/custom_objects/[string custom_object_key]/fields(CustomObjectFieldsCreateRequest payload, string accept = "application/json") returns CustomObjectFieldResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/fields`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        CustomObjectFieldResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Show Custom Object Field
    #
    # + custom_object_key - The key of a custom object
    # + custom_object_field_key_or_id - The key or id of a custom object field
    # + return - Custom Object Field
    resource isolated function get api/v2/custom_objects/[string custom_object_key]/fields/[string custom_object_field_key_or_id](string accept = "application/json") returns CustomObjectFieldResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/fields/${getEncodedUri(custom_object_field_key_or_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CustomObjectFieldResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Delete Custom Object Field
    #
    # + custom_object_key - The key of a custom object
    # + custom_object_field_key_or_id - The key or id of a custom object field
    # + return - No content response
    resource isolated function delete api/v2/custom_objects/[string custom_object_key]/fields/[string custom_object_field_key_or_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/fields/${getEncodedUri(custom_object_field_key_or_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Update Custom Object Field
    #
    # + custom_object_key - The key of a custom object
    # + custom_object_field_key_or_id - The key or id of a custom object field
    # + return - Success response
    resource isolated function patch api/v2/custom_objects/[string custom_object_key]/fields/[string custom_object_field_key_or_id](string accept = "application/json") returns CustomObjectFieldResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/fields/${getEncodedUri(custom_object_field_key_or_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        CustomObjectFieldResponse response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Reorder Custom Fields of an Object
    #
    # + custom_object_key - The key of a custom object
    # + return - Reordered
    resource isolated function put api/v2/custom_objects/[string custom_object_key]/fields/reorder(string accept = "application/json") returns string|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/fields/reorder`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        string response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Custom Object Record Bulk Jobs
    #
    # + custom_object_key - The key of a custom object
    # + return - Created
    resource isolated function post api/v2/custom_objects/[string custom_object_key]/jobs(CustomObjectRecordsBulkCreateRequest payload, string accept = "application/json") returns CustomObjectRecordsJobsResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/jobs`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        CustomObjectRecordsJobsResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Custom Object Fields Limit
    #
    # + custom_object_key - The key of a custom object
    # + return - Success response
    resource isolated function get api/v2/custom_objects/[string custom_object_key]/limits/field_limit(string accept = "application/json") returns CustomObjectLimitsResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/limits/field_limit`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CustomObjectLimitsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Custom Object Records
    #
    # + custom_object_key - The key of a custom object
    # + filterIds - Optional comma-separated list of ids to filter records by. If one or more ids are specified, only matching records are returned. The ids must be unique and are case sensitive.
    # + filterExternal_ids - Optional comma-separated list of external ids to filter records by. If one or more ids are specified, only matching records are returned. The ids must be unique and are case sensitive.
    # + sort - One of `id`, `updated_at`, `-id`, or `-updated_at`. The `-` denotes the sort will be descending.
    # + pageBefore - A [pagination cursor](/documentation/api-basics/pagination/paginating-through-lists-using-cursor-pagination) that tells the endpoint which page to start on. It should be a `meta.before_cursor` value from a previous request. Note: `page[before]` and `page[after]` can't be used together in the same request.
    # + pageAfter - A [pagination cursor](/documentation/api-basics/pagination/paginating-through-lists-using-cursor-pagination) that tells the endpoint which page to start on. It should be a `meta.after_cursor` value from a previous request. Note: `page[before]` and `page[after]` can't be used together in the same request.
    # + pageSize - Specifies how many records should be returned in the response. You can specify up to 100 records per page.
    # + return - Success response
    resource isolated function get api/v2/custom_objects/[string custom_object_key]/records(string accept = "application/json", string? filterIds = (), string? filterExternal_ids = (), string? sort = (), string? pageBefore = (), string? pageAfter = (), int? pageSize = ()) returns CustomObjectRecordsResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records`;
        map<anydata> queryParam = {"filter[ids]": filterIds, "filter[external_ids]": filterExternal_ids, "sort": sort, "page[before]": pageBefore, "page[after]": pageAfter, "page[size]": pageSize};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CustomObjectRecordsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Custom Object Record
    #
    # + custom_object_key - The key of a custom object
    # + return - Created
    resource isolated function post api/v2/custom_objects/[string custom_object_key]/records(CustomObjectRecordsCreateRequest payload, string accept = "application/json") returns CustomObjectRecordResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        CustomObjectRecordResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Custom Object Record by External Id
    #
    # + custom_object_key - The key of a custom object
    # + external_id - The external id of a custom object record
    # + return - No content response
    resource isolated function delete api/v2/custom_objects/[string custom_object_key]/records(string external_id, string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records`;
        map<anydata> queryParam = {"external_id": external_id};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Set Custom Object Record by External Id
    #
    # + custom_object_key - The key of a custom object
    # + external_id - The external id of a custom object record
    # + return - Success
    resource isolated function patch api/v2/custom_objects/[string custom_object_key]/records(string external_id, CustomObjectRecordsUpsertRequest payload, string accept = "application/json") returns CustomObjectRecordResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records`;
        map<anydata> queryParam = {"external_id": external_id};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        CustomObjectRecordResponse response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Show Custom Object Record
    #
    # + custom_object_key - The key of a custom object
    # + custom_object_record_id - The id of a custom object record
    # + return - Custom Object Record
    resource isolated function get api/v2/custom_objects/[string custom_object_key]/records/[string custom_object_record_id](string accept = "application/json") returns CustomObjectRecordResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records/${getEncodedUri(custom_object_record_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CustomObjectRecordResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Delete Custom Object Record
    #
    # + custom_object_key - The key of a custom object
    # + custom_object_record_id - The id of a custom object record
    # + return - No content response
    resource isolated function delete api/v2/custom_objects/[string custom_object_key]/records/[string custom_object_record_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records/${getEncodedUri(custom_object_record_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Update Custom Object Record
    #
    # + custom_object_key - The key of a custom object
    # + custom_object_record_id - The id of a custom object record
    # + return - Success response
    resource isolated function patch api/v2/custom_objects/[string custom_object_key]/records/[string custom_object_record_id](string accept = "application/json") returns CustomObjectRecordResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records/${getEncodedUri(custom_object_record_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        CustomObjectRecordResponse response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Autocomplete Custom Object Record Search
    #
    # + custom_object_key - The key of a custom object
    # + name - Part of a name of the record you are searching for
    # + pageBefore - A [pagination cursor](/documentation/api-basics/pagination/paginating-through-lists-using-cursor-pagination) that tells the endpoint which page to start on. It should be a `meta.before_cursor` value from a previous request. Note: `page[before]` and `page[after]` can't be used together in the same request.
    # + pageAfter - A [pagination cursor](/documentation/api-basics/pagination/paginating-through-lists-using-cursor-pagination) that tells the endpoint which page to start on. It should be a `meta.after_cursor` value from a previous request. Note: `page[before]` and `page[after]` can't be used together in the same request.
    # + pageSize - The number of records to return in the response. You can specify up to 100 records per page.
    # + field_id - The id of the lookup field. If the field has a relationship filter, the filter is applied to the results. Must be used with `source` param.
    # + 'source - One of "zen:user", "zen:ticket", "zen:organization", or "zen:custom_object:CUSTOM_OBJECT_KEY". Represents the object `field_id` belongs to. Must be used with field_id param.
    # + return - Success response
    resource isolated function get api/v2/custom_objects/[string custom_object_key]/records/autocomplete(string accept = "application/json", string? name = (), string? pageBefore = (), string? pageAfter = (), int? pageSize = (), string? field_id = (), string? 'source = ()) returns CustomObjectRecordsResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records/autocomplete`;
        map<anydata> queryParam = {"name": name, "page[before]": pageBefore, "page[after]": pageAfter, "page[size]": pageSize, "field_id": field_id, "source": 'source};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CustomObjectRecordsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Count Custom Object Records
    #
    # + custom_object_key - The key of a custom object
    # + return - Success response
    resource isolated function get api/v2/custom_objects/[string custom_object_key]/records/count(string accept = "application/json") returns Inline_response_200_1|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records/count`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Inline_response_200_1 response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Search Custom Object Records
    #
    # + custom_object_key - The key of a custom object
    # + query - The query parameter is used to search text-based fields for records that match specific query terms.
    # The query can be multiple words or numbers. Every record that matches the beginning of any word or number in the query string is returned.<br/><br/>
    # For example, you might want to search for records related to Tesla vehicles: `query=Tesla`. In this example the API would return every record for the given custom object where any of the text fields contain the word 'Tesla'.<br/><br/>
    # If needed, you could include multiple words or numbers in your search. For example: `query=Tesla Honda 2020`. This would be URL encoded as `query=Tesla%20Honda%202020`. In this example, the API would return every record for the custom object for which any of the text fields contained 'Tesla', 'Honda', or '2020'.
    # + sort - One of `name`, `created_at`, `updated_at`, `-name`, `-created_at`, or `-updated_at`. The `-` denotes the sort will be descending. Defaults to sorting by relevance.
    # + pageBefore - A [pagination cursor](/documentation/api-basics/pagination/paginating-through-lists-using-cursor-pagination) that tells the endpoint which page to start on. It should be a `meta.before_cursor` value from a previous request. Note: `page[before]` and `page[after]` can't be used together in the same request.
    # + pageAfter - A [pagination cursor](/documentation/api-basics/pagination/paginating-through-lists-using-cursor-pagination) that tells the endpoint which page to start on. It should be a `meta.after_cursor` value from a previous request. Note: `page[before]` and `page[after]` can't be used together in the same request.
    # + pageSize - Specifies how many records should be returned in the response. You can specify up to 100 records per page.
    # + return - Success response
    resource isolated function get api/v2/custom_objects/[string custom_object_key]/records/search(string accept = "application/json", string? query = (), string? sort = (), string? pageBefore = (), string? pageAfter = (), int? pageSize = ()) returns CustomObjectRecordsResponse|error {
        string resourcePath = string `/api/v2/custom_objects/${getEncodedUri(custom_object_key)}/records/search`;
        map<anydata> queryParam = {"query": query, "sort": sort, "page[before]": pageBefore, "page[after]": pageAfter, "page[size]": pageSize};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CustomObjectRecordsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Custom Objects Limit
    #
    # + return - Success response
    resource isolated function get api/v2/custom_objects/limits/object_limit() returns CustomObjectLimitsResponse|error {
        string resourcePath = string `/api/v2/custom_objects/limits/object_limit`;
        CustomObjectLimitsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Custom Object Records Limit
    #
    # + return - Success response
    resource isolated function get api/v2/custom_objects/limits/record_limit() returns CustomObjectLimitsResponse|error {
        string resourcePath = string `/api/v2/custom_objects/limits/record_limit`;
        CustomObjectLimitsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List Custom Roles
    #
    # + return - Success response
    resource isolated function get api/v2/custom_roles() returns CustomRolesResponse|error {
        string resourcePath = string `/api/v2/custom_roles`;
        CustomRolesResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Custom Role
    #
    # + return - Created response
    resource isolated function post api/v2/custom_roles() returns CustomRoleResponse|error {
        string resourcePath = string `/api/v2/custom_roles`;
        http:Request request = new;
        CustomRoleResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Custom Role
    #
    # + custom_role_id - The ID of the custom agent role
    # + return - Success response
    resource isolated function get api/v2/custom_roles/[int custom_role_id](string accept = "application/json") returns CustomRoleResponse|error {
        string resourcePath = string `/api/v2/custom_roles/${getEncodedUri(custom_role_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CustomRoleResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Custom Role
    #
    # + custom_role_id - The ID of the custom agent role
    # + return - Success response
    resource isolated function put api/v2/custom_roles/[int custom_role_id](string accept = "application/json") returns CustomRoleResponse|error {
        string resourcePath = string `/api/v2/custom_roles/${getEncodedUri(custom_role_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        CustomRoleResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Custom Role
    #
    # + custom_role_id - The ID of the custom agent role
    # + return - No Contetnt response
    resource isolated function delete api/v2/custom_roles/[int custom_role_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/custom_roles/${getEncodedUri(custom_role_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Bulk Update Default Custom Ticket Status
    #
    # + return - Updated
    resource isolated function put api/v2/custom_status/default(BulkUpdateDefaultCustomStatusRequest payload) returns BulkUpdateDefaultCustomStatusResponse|error {
        string resourcePath = string `/api/v2/custom_status/default`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        BulkUpdateDefaultCustomStatusResponse response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # List Custom Ticket Statuses
    #
    # + status_categories - Filter the list of custom ticket statuses by a comma-separated list of status categories
    # + active - If true, show only active custom ticket statuses. If false, show only inactive custom ticket statuses. If the filter is not used, show all custom ticket statuses
    # + default - If true, show only default custom ticket statuses. If false, show only non-default custom ticket statuses. If the filter is not used, show all custom ticket statuses
    # + return - List custom ticket statuses
    resource isolated function get api/v2/custom_statuses(string accept = "application/json", string? status_categories = (), boolean? active = (), boolean? default = ()) returns CustomStatusesResponse|error {
        string resourcePath = string `/api/v2/custom_statuses`;
        map<anydata> queryParam = {"status_categories": status_categories, "active": active, "default": default};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CustomStatusesResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Custom Ticket Status
    #
    # + return - Created
    resource isolated function post api/v2/custom_statuses(CustomStatusCreateRequest payload) returns CustomStatusResponse|error {
        string resourcePath = string `/api/v2/custom_statuses`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        CustomStatusResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Custom Ticket Status
    #
    # + custom_status_id - The id of the custom status
    # + return - Custom Status
    resource isolated function get api/v2/custom_statuses/[int custom_status_id](string accept = "application/json") returns CustomStatusResponse|error {
        string resourcePath = string `/api/v2/custom_statuses/${getEncodedUri(custom_status_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CustomStatusResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Custom Ticket Status
    #
    # + custom_status_id - The id of the custom status
    # + return - Updated
    resource isolated function put api/v2/custom_statuses/[int custom_status_id](CustomStatusUpdateRequest payload, string accept = "application/json") returns CustomStatusResponse|error {
        string resourcePath = string `/api/v2/custom_statuses/${getEncodedUri(custom_status_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        CustomStatusResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # List Deleted Tickets
    #
    # + sort_by - Sort by
    # + sort_order - Sort order. Defaults to "asc"
    # + return - Successful response
    resource isolated function get api/v2/deleted_tickets(string accept = "application/json", "id"|"subject"|"deleted_at"? sort_by = (), "asc"|"desc"? sort_order = ()) returns ListDeletedTicketsResponse|error {
        string resourcePath = string `/api/v2/deleted_tickets`;
        map<anydata> queryParam = {"sort_by": sort_by, "sort_order": sort_order};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ListDeletedTicketsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Delete Ticket Permanently
    #
    # + ticket_id - The ID of the ticket
    # + return - Successful response
    resource isolated function delete api/v2/deleted_tickets/[int ticket_id](string accept = "application/json") returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/deleted_tickets/${getEncodedUri(ticket_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        JobStatusResponse response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Restore a Previously Deleted Ticket
    #
    # + ticket_id - The ID of the ticket
    # + return - Empty response
    resource isolated function put api/v2/deleted_tickets/[int ticket_id]/restore(string accept = "application/json") returns string|error {
        string resourcePath = string `/api/v2/deleted_tickets/${getEncodedUri(ticket_id)}/restore`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        string response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Multiple Tickets Permanently
    #
    # + ids - Comma-separated list of ticket ids
    # + return - Successful response
    resource isolated function delete api/v2/deleted_tickets/destroy_many(string ids, string accept = "application/json") returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/deleted_tickets/destroy_many`;
        map<anydata> queryParam = {"ids": ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        JobStatusResponse response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Restore Previously Deleted Tickets in Bulk
    #
    # + ids - Comma-separated list of ticket ids
    # + return - Empty response
    resource isolated function put api/v2/deleted_tickets/restore_many(string ids, string accept = "application/json") returns string|error {
        string resourcePath = string `/api/v2/deleted_tickets/restore_many`;
        map<anydata> queryParam = {"ids": ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        string response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # List Deleted Users
    #
    # + return - Success response
    resource isolated function get api/v2/deleted_users() returns DeletedUsersResponse|error {
        string resourcePath = string `/api/v2/deleted_users`;
        DeletedUsersResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Show Deleted User
    #
    # + deleted_user_id - The ID of the deleted user
    # + return - Success response
    resource isolated function get api/v2/deleted_users/[int deleted_user_id](string accept = "application/json") returns DeletedUserResponse|error {
        string resourcePath = string `/api/v2/deleted_users/${getEncodedUri(deleted_user_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        DeletedUserResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Permanently Delete User
    #
    # + deleted_user_id - The ID of the deleted user
    # + return - Success response
    resource isolated function delete api/v2/deleted_users/[int deleted_user_id](string accept = "application/json") returns DeletedUserResponse|error {
        string resourcePath = string `/api/v2/deleted_users/${getEncodedUri(deleted_user_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        DeletedUserResponse response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Count Deleted Users
    #
    # + return - Success response
    resource isolated function get api/v2/deleted_users/count() returns CountResponse|error {
        string resourcePath = string `/api/v2/deleted_users/count`;
        CountResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List Items
    #
    # + return - Success response
    resource isolated function get api/v2/dynamic_content/items() returns DynamicContentsResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items`;
        DynamicContentsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Item
    #
    # + return - Created response
    resource isolated function post api/v2/dynamic_content/items() returns DynamicContentResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items`;
        http:Request request = new;
        DynamicContentResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Item
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + return - Success response
    resource isolated function get api/v2/dynamic_content/items/[int dynamic_content_item_id](string accept = "application/json") returns DynamicContentResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        DynamicContentResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Item
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + return - Success response
    resource isolated function put api/v2/dynamic_content/items/[int dynamic_content_item_id](string accept = "application/json") returns DynamicContentResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        DynamicContentResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Item
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + return - No Content response
    resource isolated function delete api/v2/dynamic_content/items/[int dynamic_content_item_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # List Variants
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + return - Success response
    resource isolated function get api/v2/dynamic_content/items/[int dynamic_content_item_id]/variants(string accept = "application/json") returns DynamicContentVariantsResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}/variants`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        DynamicContentVariantsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Variant
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + return - Created response
    resource isolated function post api/v2/dynamic_content/items/[int dynamic_content_item_id]/variants(string accept = "application/json") returns DynamicContentVariantResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}/variants`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        DynamicContentVariantResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Show Variant
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + dynammic_content_variant_id - The ID of the variant
    # + return - Success response
    resource isolated function get api/v2/dynamic_content/items/[int dynamic_content_item_id]/variants/[int dynammic_content_variant_id](string accept = "application/json") returns DynamicContentVariantResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}/variants/${getEncodedUri(dynammic_content_variant_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        DynamicContentVariantResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Variant
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + dynammic_content_variant_id - The ID of the variant
    # + return - Success response
    resource isolated function put api/v2/dynamic_content/items/[int dynamic_content_item_id]/variants/[int dynammic_content_variant_id](string accept = "application/json") returns DynamicContentVariantResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}/variants/${getEncodedUri(dynammic_content_variant_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        DynamicContentVariantResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Variant
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + dynammic_content_variant_id - The ID of the variant
    # + return - No Content response
    resource isolated function delete api/v2/dynamic_content/items/[int dynamic_content_item_id]/variants/[int dynammic_content_variant_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}/variants/${getEncodedUri(dynammic_content_variant_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Create Many Variants
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + return - Created response
    resource isolated function post api/v2/dynamic_content/items/[int dynamic_content_item_id]/variants/create_many(string accept = "application/json") returns DynamicContentVariantsResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}/variants/create_many`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        DynamicContentVariantsResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Update Many Variants
    #
    # + dynamic_content_item_id - The ID of the dynamic content item
    # + return - Success response
    resource isolated function put api/v2/dynamic_content/items/[int dynamic_content_item_id]/variants/update_many(string accept = "application/json") returns DynamicContentVariantsResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/${getEncodedUri(dynamic_content_item_id)}/variants/update_many`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        DynamicContentVariantsResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Show Many Items
    #
    # + identifiers - Identifiers for the dynamic contents
    # + return - Success response
    resource isolated function get api/v2/dynamic_content/items/show_many(string accept = "application/json", string? identifiers = ()) returns DynamicContentsResponse|error {
        string resourcePath = string `/api/v2/dynamic_content/items/show_many`;
        map<anydata> queryParam = {"identifiers": identifiers};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        DynamicContentsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Memberships
    #
    # + return - Success response
    resource isolated function get api/v2/group_memberships() returns GroupMembershipsResponse|error {
        string resourcePath = string `/api/v2/group_memberships`;
        GroupMembershipsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Membership
    #
    # + return - Created response
    resource isolated function post api/v2/group_memberships() returns GroupMembershipResponse|error {
        string resourcePath = string `/api/v2/group_memberships`;
        http:Request request = new;
        GroupMembershipResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Membership
    #
    # + group_membership_id - The ID of the group membership
    # + user_id - The id of the user
    # + return - Success response
    resource isolated function get api/v2/group_memberships/[int group_membership_id](string accept = "application/json") returns GroupMembershipResponse|error {
        string resourcePath = string `/api/v2/group_memberships/${getEncodedUri(group_membership_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        GroupMembershipResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Delete Membership
    #
    # + group_membership_id - The ID of the group membership
    # + user_id - The id of the user
    # + return - No content response
    resource isolated function delete api/v2/group_memberships/[int group_membership_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/group_memberships/${getEncodedUri(group_membership_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # List Assignable Memberships
    #
    # + return - Success response
    resource isolated function get api/v2/group_memberships/assignable() returns GroupMembershipsResponse|error {
        string resourcePath = string `/api/v2/group_memberships/assignable`;
        GroupMembershipsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Bulk Create Memberships
    #
    # + return - Success response
    resource isolated function post api/v2/group_memberships/create_many() returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/group_memberships/create_many`;
        http:Request request = new;
        JobStatusResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Bulk Delete Memberships
    #
    # + ids - Id of the group memberships to delete. Comma separated
    # + return - Success response
    resource isolated function delete api/v2/group_memberships/destroy_many(string accept = "application/json", string? ids = ()) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/group_memberships/destroy_many`;
        map<anydata> queryParam = {"ids": ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        JobStatusResponse response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # List Group SLA Policies
    #
    # + return - Success response
    resource isolated function get api/v2/group_slas/policies() returns GroupSLAPoliciesResponse|error {
        string resourcePath = string `/api/v2/group_slas/policies`;
        GroupSLAPoliciesResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Group SLA Policy
    #
    # + return - Created response
    resource isolated function post api/v2/group_slas/policies() returns GroupSLAPolicyResponse|error {
        string resourcePath = string `/api/v2/group_slas/policies`;
        http:Request request = new;
        GroupSLAPolicyResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Group SLA Policy
    #
    # + group_sla_policy_id - The id of the Group SLA policy
    # + return - Success response
    resource isolated function get api/v2/group_slas/policies/[int group_sla_policy_id](string accept = "application/json") returns GroupSLAPolicyResponse|error {
        string resourcePath = string `/api/v2/group_slas/policies/${getEncodedUri(group_sla_policy_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        GroupSLAPolicyResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Group SLA Policy
    #
    # + group_sla_policy_id - The id of the Group SLA policy
    # + return - Success response
    resource isolated function put api/v2/group_slas/policies/[int group_sla_policy_id](string accept = "application/json") returns GroupSLAPolicyResponse|error {
        string resourcePath = string `/api/v2/group_slas/policies/${getEncodedUri(group_sla_policy_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        GroupSLAPolicyResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Group SLA Policy
    #
    # + group_sla_policy_id - The id of the Group SLA policy
    # + return - No Content response
    resource isolated function delete api/v2/group_slas/policies/[int group_sla_policy_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/group_slas/policies/${getEncodedUri(group_sla_policy_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Retrieve Supported Filter Definition Items
    #
    # + return - Success response
    resource isolated function get api/v2/group_slas/policies/definitions() returns GroupSLAPolicyFilterDefinitionResponse|error {
        string resourcePath = string `/api/v2/group_slas/policies/definitions`;
        GroupSLAPolicyFilterDefinitionResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Reorder Group SLA Policies
    #
    # + group_sla_policy_ids - The ids of the Group SLA policies to reorder
    # + return - Success response
    resource isolated function put api/v2/group_slas/policies/reorder(string accept = "application/json", string[]? group_sla_policy_ids = ()) returns string|error {
        string resourcePath = string `/api/v2/group_slas/policies/reorder`;
        map<anydata> queryParam = {"group_sla_policy_ids": group_sla_policy_ids};
        map<Encoding> queryParamEncoding = {"group_sla_policy_ids": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam, queryParamEncoding);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        string response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # List Groups
    #
    # + user_id - The id of the user
    # + exclude_deleted - Whether to exclude deleted entities
    # + return - Success response
    resource isolated function get api/v2/groups(string accept = "application/json", boolean? exclude_deleted = ()) returns GroupsResponse|error {
        string resourcePath = string `/api/v2/groups`;
        map<anydata> queryParam = {"exclude_deleted": exclude_deleted};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        GroupsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Group
    #
    # + return - Created response
    resource isolated function post api/v2/groups() returns GroupResponse|error {
        string resourcePath = string `/api/v2/groups`;
        http:Request request = new;
        GroupResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Group
    #
    # + group_id - The ID of the group
    # + return - Success response
    resource isolated function get api/v2/groups/[int group_id](string accept = "application/json") returns GroupResponse|error {
        string resourcePath = string `/api/v2/groups/${getEncodedUri(group_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        GroupResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Group
    #
    # + group_id - The ID of the group
    # + return - Success response
    resource isolated function put api/v2/groups/[int group_id](string accept = "application/json") returns GroupResponse|error {
        string resourcePath = string `/api/v2/groups/${getEncodedUri(group_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        GroupResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Group
    #
    # + group_id - The ID of the group
    # + return - No content response
    resource isolated function delete api/v2/groups/[int group_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/groups/${getEncodedUri(group_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # List Memberships
    #
    # + group_id - The ID of the group
    # + return - Success response
    resource isolated function get api/v2/groups/[int group_id]/memberships(string accept = "application/json") returns GroupMembershipsResponse|error {
        string resourcePath = string `/api/v2/groups/${getEncodedUri(group_id)}/memberships`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        GroupMembershipsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Assignable Groups
    #
    # + return - Success response
    resource isolated function get api/v2/groups/assignable() returns GroupsResponse|error {
        string resourcePath = string `/api/v2/groups/assignable`;
        GroupsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Count Groups
    #
    # + user_id - The id of the user
    # + return - Success response
    resource isolated function get api/v2/groups/count(string accept = "application/json") returns GroupsCountObject|error {
        string resourcePath = string `/api/v2/groups/count`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        GroupsCountObject response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Ticket Import
    #
    # + archive_immediately - If `true`, any ticket created with a `closed` status bypasses the normal ticket lifecycle and will be created directly in your ticket archive
    # + return - Successfully created
    resource isolated function post api/v2/imports/tickets(TicketImportRequest payload, string accept = "application/json", boolean? archive_immediately = ()) returns TicketResponse|error {
        string resourcePath = string `/api/v2/imports/tickets`;
        map<anydata> queryParam = {"archive_immediately": archive_immediately};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        TicketResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Ticket Bulk Import
    #
    # + archive_immediately - If `true`, any ticket created with a `closed` status bypasses the normal ticket lifecycle and will be created directly in your ticket archive
    # + return - Successful response
    resource isolated function post api/v2/imports/tickets/create_many(TicketBulkImportRequest payload, string accept = "application/json", boolean? archive_immediately = ()) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/imports/tickets/create_many`;
        map<anydata> queryParam = {"archive_immediately": archive_immediately};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        JobStatusResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Incremental Sample Export
    #
    # + start_time - The time to start the incremental export from. Must be at least one minute in the past. Data isn't provided for the most recent minute
    # + incremental_resource - The resource requested for incremental sample export
    # + return - Success response
    resource isolated function get api/v2/incremental/[string incremental_resource]/sample(int start_time, string accept = "application/json") returns TimeBasedExportIncrementalTicketsResponse|error {
        string resourcePath = string `/api/v2/incremental/${getEncodedUri(incremental_resource)}/sample`;
        map<anydata> queryParam = {"start_time": start_time};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TimeBasedExportIncrementalTicketsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Incremental Organization Export
    #
    # + start_time - The time to start the incremental export from. Must be at least one minute in the past. Data isn't provided for the most recent minute
    # + return - Success response
    resource isolated function get api/v2/incremental/organizations(int start_time, string accept = "application/json") returns ExportIncrementalOrganizationsResponse|error {
        string resourcePath = string `/api/v2/incremental/organizations`;
        map<anydata> queryParam = {"start_time": start_time};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ExportIncrementalOrganizationsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Incremental Attributes Values Export
    #
    # + return - Success response
    resource isolated function get api/v2/incremental/routing/attribute_values() returns IncrementalSkillBasedRouting|error {
        string resourcePath = string `/api/v2/incremental/routing/attribute_values`;
        IncrementalSkillBasedRouting response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Incremental Attributes Export
    #
    # + return - Success response
    resource isolated function get api/v2/incremental/routing/attributes() returns IncrementalSkillBasedRouting|error {
        string resourcePath = string `/api/v2/incremental/routing/attributes`;
        IncrementalSkillBasedRouting response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Incremental Instance Values Export
    #
    # + return - Success response
    resource isolated function get api/v2/incremental/routing/instance_values() returns IncrementalSkillBasedRouting|error {
        string resourcePath = string `/api/v2/incremental/routing/instance_values`;
        IncrementalSkillBasedRouting response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Incremental Ticket Event Export
    #
    # + start_time - The time to start the incremental export from. Must be at least one minute in the past. Data isn't provided for the most recent minute
    # + return - Success response
    resource isolated function get api/v2/incremental/ticket_events(int start_time, string accept = "application/json") returns ExportIncrementalTicketEventsResponse|error {
        string resourcePath = string `/api/v2/incremental/ticket_events`;
        map<anydata> queryParam = {"start_time": start_time};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ExportIncrementalTicketEventsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Ticket Metric Events
    #
    # + start_time - The Unix UTC epoch time of the oldest event you're interested in. Example: 1332034771.
    # + return - Successful response
    resource isolated function get api/v2/incremental/ticket_metric_events(int start_time, string accept = "application/json") returns TicketMetricEventsResponse|error {
        string resourcePath = string `/api/v2/incremental/ticket_metric_events`;
        map<anydata> queryParam = {"start_time": start_time};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketMetricEventsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Incremental Ticket Export, Time Based
    #
    # + start_time - The time to start the incremental export from. Must be at least one minute in the past. Data isn't provided for the most recent minute
    # + return - Success response
    resource isolated function get api/v2/incremental/tickets(int start_time, string accept = "application/json") returns TimeBasedExportIncrementalTicketsResponse|error {
        string resourcePath = string `/api/v2/incremental/tickets`;
        map<anydata> queryParam = {"start_time": start_time};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TimeBasedExportIncrementalTicketsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Incremental Ticket Export, Cursor Based
    #
    # + start_time - The time to start the incremental export from. Must be at least one minute in the past. Data isn't provided for the most recent minute
    # + cursor - The cursor pointer to work with for all subsequent exports after the initial request
    # + return - Success response
    resource isolated function get api/v2/incremental/tickets/cursor(int start_time, string accept = "application/json", string? cursor = ()) returns CursorBasedExportIncrementalTicketsResponse|error {
        string resourcePath = string `/api/v2/incremental/tickets/cursor`;
        map<anydata> queryParam = {"start_time": start_time, "cursor": cursor};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CursorBasedExportIncrementalTicketsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Incremental User Export, Time Based
    #
    # + start_time - The time to start the incremental export from. Must be at least one minute in the past. Data isn't provided for the most recent minute
    # + per_page - The number of records to return per page
    # + return - Success response
    resource isolated function get api/v2/incremental/users(int start_time, string accept = "application/json", int? per_page = ()) returns TimeBasedExportIncrementalUsersResponse|error {
        string resourcePath = string `/api/v2/incremental/users`;
        map<anydata> queryParam = {"start_time": start_time, "per_page": per_page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TimeBasedExportIncrementalUsersResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Incremental User Export, Cursor Based
    #
    # + start_time - The time to start the incremental export from. Must be at least one minute in the past. Data isn't provided for the most recent minute
    # + cursor - The cursor pointer to work with for all subsequent exports after the initial request
    # + per_page - The number of records to return per page
    # + return - Success response
    resource isolated function get api/v2/incremental/users/cursor(int start_time, string accept = "application/json", string? cursor = (), int? per_page = ()) returns CursorBasedExportIncrementalUsersResponse|error {
        string resourcePath = string `/api/v2/incremental/users/cursor`;
        map<anydata> queryParam = {"start_time": start_time, "cursor": cursor, "per_page": per_page};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CursorBasedExportIncrementalUsersResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Job Statuses
    #
    # + return - Success Response
    resource isolated function get api/v2/job_statuses() returns JobStatusesResponse|error {
        string resourcePath = string `/api/v2/job_statuses`;
        JobStatusesResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Show Job Status
    #
    # + job_status_id - the Id of the Job status
    # + return - Success Response
    resource isolated function get api/v2/job_statuses/[string job_status_id](string accept = "application/json") returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/job_statuses/${getEncodedUri(job_status_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        JobStatusResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Show Many Job Statuses
    #
    # + ids - Comma-separated list of job status ids.
    # + return - Success Response
    resource isolated function get api/v2/job_statuses/show_many(string ids, string accept = "application/json") returns JobStatusesResponse|error {
        string resourcePath = string `/api/v2/job_statuses/show_many`;
        map<anydata> queryParam = {"ids": ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        JobStatusesResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Locales
    #
    # + return - Success response
    resource isolated function get api/v2/locales() returns LocalesResponse|error {
        string resourcePath = string `/api/v2/locales`;
        LocalesResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Show Locale
    #
    # + locale_id - The ID or the [BCP-47 code](https://en.wikipedia.org/wiki/IETF_language_tag) of the locale. Examples: es-419, en-us, pr-br
    # + return - Success Response
    resource isolated function get api/v2/locales/[string locale_id](string accept = "application/json") returns LocaleResponse|error {
        string resourcePath = string `/api/v2/locales/${getEncodedUri(locale_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        LocaleResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Locales for Agent
    #
    # + return - Success response
    resource isolated function get api/v2/locales/agent() returns LocalesResponse|error {
        string resourcePath = string `/api/v2/locales/agent`;
        LocalesResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Show Current Locale
    #
    # + return - Success response
    resource isolated function get api/v2/locales/current() returns LocaleResponse|error {
        string resourcePath = string `/api/v2/locales/current`;
        LocaleResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Detect Best Language for User
    #
    # + return - Success response
    resource isolated function get api/v2/locales/detect_best_locale() returns LocaleResponse|error {
        string resourcePath = string `/api/v2/locales/detect_best_locale`;
        LocaleResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List Available Public Locales
    #
    # + return - Success response
    resource isolated function get api/v2/locales/'public() returns LocalesResponse|error {
        string resourcePath = string `/api/v2/locales/public`;
        LocalesResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List Macros
    #
    # + include - A sideload to include in the response. See [Sideloads](#sideloads-2)
    # + access - Filter macros by access. Possible values are "personal", "agents", "shared", or "account". The "agents" value returns all personal macros for the account's agents and is only available to admins.
    # + active - Filter by active macros if true or inactive macros if false
    # + category - Filter macros by category
    # + group_id - Filter macros by group
    # + only_viewable - If true, returns only macros that can be applied to tickets. If false, returns all macros the current user can manage. Default is false
    # + sort_by - Possible values are alphabetical, "created_at", "updated_at", "usage_1h", "usage_24h", "usage_7d", or "usage_30d". Defaults to alphabetical
    # + sort_order - One of "asc" or "desc". Defaults to "asc" for alphabetical and position sort, "desc" for all others
    # + return - Success Response
    resource isolated function get api/v2/macros(string accept = "application/json", string? include = (), string? access = (), boolean? active = (), int? category = (), int? group_id = (), boolean? only_viewable = (), string? sort_by = (), string? sort_order = ()) returns MacrosResponse|error {
        string resourcePath = string `/api/v2/macros`;
        map<anydata> queryParam = {"include": include, "access": access, "active": active, "category": category, "group_id": group_id, "only_viewable": only_viewable, "sort_by": sort_by, "sort_order": sort_order};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        MacrosResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Macro
    #
    # + return - OK
    resource isolated function post api/v2/macros(V2_macros_body payload) returns Inline_response_200_2|error {
        string resourcePath = string `/api/v2/macros`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Inline_response_200_2 response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Macro
    #
    # + macro_id - The ID of the macro
    # + return - Success Response
    resource isolated function get api/v2/macros/[int macro_id](string accept = "application/json") returns MacroResponse|error {
        string resourcePath = string `/api/v2/macros/${getEncodedUri(macro_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        MacroResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Macro
    #
    # + macro_id - The ID of the macro
    # + return - OK
    resource isolated function put api/v2/macros/[int macro_id](Macros_macro_id_body payload, string accept = "application/json") returns Inline_response_200_2|error {
        string resourcePath = string `/api/v2/macros/${getEncodedUri(macro_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Inline_response_200_2 response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Macro
    #
    # + macro_id - The ID of the macro
    # + return - No Content
    resource isolated function delete api/v2/macros/[int macro_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/macros/${getEncodedUri(macro_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Show Changes to Ticket
    #
    # + macro_id - The ID of the macro
    # + return - Success Response
    resource isolated function get api/v2/macros/[int macro_id]/apply(string accept = "application/json") returns MacroApplyTicketResponse|error {
        string resourcePath = string `/api/v2/macros/${getEncodedUri(macro_id)}/apply`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        MacroApplyTicketResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Macro Attachments
    #
    # + macro_id - The ID of the macro
    # + return - Success Response
    resource isolated function get api/v2/macros/[int macro_id]/attachments(string accept = "application/json") returns MacroAttachmentsResponse|error {
        string resourcePath = string `/api/v2/macros/${getEncodedUri(macro_id)}/attachments`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        MacroAttachmentsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Macro Attachment
    #
    # + macro_id - The ID of the macro
    # + return - Success Response
    resource isolated function post api/v2/macros/[int macro_id]/attachments(string accept = "application/json") returns MacroAttachmentResponse|error {
        string resourcePath = string `/api/v2/macros/${getEncodedUri(macro_id)}/attachments`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        MacroAttachmentResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # List Supported Actions for Macros
    #
    # + return - Success Response
    resource isolated function get api/v2/macros/actions() returns Inline_response_200_3|error {
        string resourcePath = string `/api/v2/macros/actions`;
        Inline_response_200_3 response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List Active Macros
    #
    # + include - A sideload to include in the response. See [Sideloads](#sideloads-2)
    # + access - Filter macros by access. Possible values are "personal", "agents", "shared", or "account". The "agents" value returns all personal macros for the account's agents and is only available to admins.
    # + category - Filter macros by category
    # + group_id - Filter macros by group
    # + sort_by - Possible values are alphabetical, "created_at", "updated_at", "usage_1h", "usage_24h", "usage_7d", or "usage_30d". Defaults to alphabetical
    # + sort_order - One of "asc" or "desc". Defaults to "asc" for alphabetical and position sort, "desc" for all others
    # + return - Success Response
    resource isolated function get api/v2/macros/active(string accept = "application/json", string? include = (), string? access = (), int? category = (), int? group_id = (), string? sort_by = (), string? sort_order = ()) returns MacrosResponse|error {
        string resourcePath = string `/api/v2/macros/active`;
        map<anydata> queryParam = {"include": include, "access": access, "category": category, "group_id": group_id, "sort_by": sort_by, "sort_order": sort_order};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        MacrosResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Unassociated Macro Attachment
    #
    # + return - Created Response
    resource isolated function post api/v2/macros/attachments() returns MacroAttachmentResponse|error {
        string resourcePath = string `/api/v2/macros/attachments`;
        http:Request request = new;
        MacroAttachmentResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Macro Attachment
    #
    # + attachment_id - The ID of the attachment
    # + return - Success Response
    resource isolated function get api/v2/macros/attachments/[int attachment_id](string accept = "application/json") returns MacroAttachmentResponse|error {
        string resourcePath = string `/api/v2/macros/attachments/${getEncodedUri(attachment_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        MacroAttachmentResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Macro Categories
    #
    # + return - Success Response
    resource isolated function get api/v2/macros/categories() returns MacroCategoriesResponse|error {
        string resourcePath = string `/api/v2/macros/categories`;
        MacroCategoriesResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List Macro Action Definitions
    #
    # + return - Success Response
    resource isolated function get api/v2/macros/definitions() returns Inline_response_200_4|error {
        string resourcePath = string `/api/v2/macros/definitions`;
        Inline_response_200_4 response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Bulk Delete Macros
    #
    # + ids - The IDs of the macros to delete
    # + return - No Content
    resource isolated function delete api/v2/macros/destroy_many(int[] ids, string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/macros/destroy_many`;
        map<anydata> queryParam = {"ids": ids};
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam, queryParamEncoding);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Show Macro Replica
    #
    # + macro_id - The ID of the macro to replicate
    # + ticket_id - The ID of the ticket from which to build a macro replica
    # + return - Success Response
    resource isolated function get api/v2/macros/'new(int macro_id, int ticket_id, string accept = "application/json") returns MacroResponse|error {
        string resourcePath = string `/api/v2/macros/new`;
        map<anydata> queryParam = {"macro_id": macro_id, "ticket_id": ticket_id};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        MacroResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Search Macros
    #
    # + include - A sideload to include in the response. See [Sideloads](#sideloads-2)
    # + access - Filter macros by access. Possible values are "personal", "agents", "shared", or "account". The "agents" value returns all personal macros for the account's agents and is only available to admins.
    # + active - Filter by active macros if true or inactive macros if false
    # + category - Filter macros by category
    # + group_id - Filter macros by group
    # + only_viewable - If true, returns only macros that can be applied to tickets. If false, returns all macros the current user can manage. Default is false
    # + sort_by - Possible values are alphabetical, "created_at", "updated_at", "usage_1h", "usage_24h", "usage_7d", or "usage_30d". Defaults to alphabetical
    # + sort_order - One of "asc" or "desc". Defaults to "asc" for alphabetical and position sort, "desc" for all others
    # + query - Query string used to find macros with matching titles
    # + return - Success Response
    resource isolated function get api/v2/macros/search(string query, string accept = "application/json", string? include = (), string? access = (), boolean? active = (), int? category = (), int? group_id = (), boolean? only_viewable = (), string? sort_by = (), string? sort_order = ()) returns MacrosResponse|error {
        string resourcePath = string `/api/v2/macros/search`;
        map<anydata> queryParam = {"include": include, "access": access, "active": active, "category": category, "group_id": group_id, "only_viewable": only_viewable, "sort_by": sort_by, "sort_order": sort_order, "query": query};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        MacrosResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Many Macros
    #
    # + return - Success Response
    resource isolated function put api/v2/macros/update_many(MacroUpdateManyInput payload) returns MacrosResponse|error {
        string resourcePath = string `/api/v2/macros/update_many`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        MacrosResponse response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Show Essentials Card
    #
    # + object_type - Essentials card type. Example: `zen:user` refers user type
    # + return - Success response
    resource isolated function get api/v2/object_layouts/[string object_type]/essentials_card(string accept = "application/json") returns EssentialsCardResponse|error {
        string resourcePath = string `/api/v2/object_layouts/${getEncodedUri(object_type)}/essentials_card`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        EssentialsCardResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Essentials Card
    #
    # + object_type - Essentials card type. Example: `zen:user` refers user type
    # + return - Success response
    resource isolated function put api/v2/object_layouts/[string object_type]/essentials_card(string accept = "application/json") returns EssentialsCardResponse|error {
        string resourcePath = string `/api/v2/object_layouts/${getEncodedUri(object_type)}/essentials_card`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        EssentialsCardResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Essentials Card
    #
    # + object_type - Essentials card type. Example: `zen:user` refers user type
    # + return - Success response
    resource isolated function delete api/v2/object_layouts/[string object_type]/essentials_card(string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/object_layouts/${getEncodedUri(object_type)}/essentials_card`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # List of Essentials Cards
    #
    # + return - Success response
    resource isolated function get api/v2/object_layouts/essentials_cards() returns EssentialsCardsResponse|error {
        string resourcePath = string `/api/v2/object_layouts/essentials_cards`;
        EssentialsCardsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List Organization Fields
    #
    # + return - Success response
    resource isolated function get api/v2/organization_fields() returns OrganizationFieldsResponse|error {
        string resourcePath = string `/api/v2/organization_fields`;
        OrganizationFieldsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Organization Field
    #
    # + return - Created response
    resource isolated function post api/v2/organization_fields() returns OrganizationFieldResponse|error {
        string resourcePath = string `/api/v2/organization_fields`;
        http:Request request = new;
        OrganizationFieldResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Organization Field
    #
    # + organization_field_id - The ID or key of the organization field
    # + return - Success response
    resource isolated function get api/v2/organization_fields/[Organization_field_id organization_field_id](string accept = "application/json") returns OrganizationFieldResponse|error {
        string resourcePath = string `/api/v2/organization_fields/${getEncodedUri(organization_field_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        OrganizationFieldResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Organization Field
    #
    # + organization_field_id - The ID or key of the organization field
    # + return - Success response
    resource isolated function put api/v2/organization_fields/[Organization_field_id organization_field_id](string accept = "application/json") returns OrganizationFieldResponse|error {
        string resourcePath = string `/api/v2/organization_fields/${getEncodedUri(organization_field_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        OrganizationFieldResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Organization Field
    #
    # + organization_field_id - The ID or key of the organization field
    # + return - No Content response
    resource isolated function delete api/v2/organization_fields/[Organization_field_id organization_field_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/organization_fields/${getEncodedUri(organization_field_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Reorder Organization Field
    #
    # + return - Success response
    resource isolated function put api/v2/organization_fields/reorder() returns string|error {
        string resourcePath = string `/api/v2/organization_fields/reorder`;
        http:Request request = new;
        string response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # List Memberships
    #
    # + return - Success response
    resource isolated function get api/v2/organization_memberships() returns OrganizationMembershipsResponse|error {
        string resourcePath = string `/api/v2/organization_memberships`;
        OrganizationMembershipsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Membership
    #
    # + return - Created response
    resource isolated function post api/v2/organization_memberships() returns OrganizationMembershipResponse|error {
        string resourcePath = string `/api/v2/organization_memberships`;
        http:Request request = new;
        OrganizationMembershipResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Membership
    #
    # + organization_membership_id - The ID of the organization membership
    # + return - Success response
    resource isolated function get api/v2/organization_memberships/[int organization_membership_id](string accept = "application/json") returns OrganizationMembershipResponse|error {
        string resourcePath = string `/api/v2/organization_memberships/${getEncodedUri(organization_membership_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        OrganizationMembershipResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Delete Membership
    #
    # + organization_membership_id - The ID of the organization membership
    # + return - No Content response
    resource isolated function delete api/v2/organization_memberships/[int organization_membership_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/organization_memberships/${getEncodedUri(organization_membership_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Create Many Memberships
    #
    # + return - Success response
    resource isolated function post api/v2/organization_memberships/create_many() returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/organization_memberships/create_many`;
        http:Request request = new;
        JobStatusResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Bulk Delete Memberships
    #
    # + ids - The IDs of the organization memberships to delete
    # + return - Success response
    resource isolated function delete api/v2/organization_memberships/destroy_many(string accept = "application/json", int[]? ids = ()) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/organization_memberships/destroy_many`;
        map<anydata> queryParam = {"ids": ids};
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam, queryParamEncoding);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        JobStatusResponse response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # List Organization Subscriptions
    #
    # + return - Successful response
    resource isolated function get api/v2/organization_subscriptions() returns OrganizationSubscriptionsResponse|error {
        string resourcePath = string `/api/v2/organization_subscriptions`;
        OrganizationSubscriptionsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Organization Subscription
    #
    # + return - Successful response
    resource isolated function post api/v2/organization_subscriptions(OrganizationSubscriptionCreateRequest payload) returns OrganizationSubscriptionResponse|error {
        string resourcePath = string `/api/v2/organization_subscriptions`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        OrganizationSubscriptionResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Organization Subscription
    #
    # + organization_subscription_id - The ID of the organization subscription
    # + return - Successful response
    resource isolated function get api/v2/organization_subscriptions/[int organization_subscription_id](string accept = "application/json") returns OrganizationSubscriptionResponse|error {
        string resourcePath = string `/api/v2/organization_subscriptions/${getEncodedUri(organization_subscription_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        OrganizationSubscriptionResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Delete Organization Subscription
    #
    # + organization_subscription_id - The ID of the organization subscription
    # + return - No content
    resource isolated function delete api/v2/organization_subscriptions/[int organization_subscription_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/organization_subscriptions/${getEncodedUri(organization_subscription_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # List Organizations
    #
    # + return - Success response
    resource isolated function get api/v2/organizations() returns OrganizationsResponse|error {
        string resourcePath = string `/api/v2/organizations`;
        OrganizationsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Organization
    #
    # + return - Created
    resource isolated function post api/v2/organizations() returns OrganizationResponse|error {
        string resourcePath = string `/api/v2/organizations`;
        http:Request request = new;
        OrganizationResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Organization
    #
    # + organization_id - The ID of an organization
    # + return - Success response
    resource isolated function get api/v2/organizations/[int organization_id](string accept = "application/json") returns OrganizationResponse|error {
        string resourcePath = string `/api/v2/organizations/${getEncodedUri(organization_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        OrganizationResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Organization
    #
    # + organization_id - The ID of an organization
    # + return - Success response
    resource isolated function put api/v2/organizations/[int organization_id](string accept = "application/json") returns OrganizationResponse|error {
        string resourcePath = string `/api/v2/organizations/${getEncodedUri(organization_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        OrganizationResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Organization
    #
    # + organization_id - The ID of an organization
    # + return - No Content Response
    resource isolated function delete api/v2/organizations/[int organization_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/organizations/${getEncodedUri(organization_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Show Organization's Related Information
    #
    # + organization_id - The ID of an organization
    # + return - Success response
    resource isolated function get api/v2/organizations/[int organization_id]/related(string accept = "application/json") returns OrganizationsRelatedResponse|error {
        string resourcePath = string `/api/v2/organizations/${getEncodedUri(organization_id)}/related`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        OrganizationsRelatedResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Autocomplete Organizations
    #
    # + name - A substring of an organization to search for
    # + field_id - The id of a lookup relationship field.  The type of field is determined
    # by the `source` param
    # + 'source - If a `field_id` is provided, this specifies the type of the field.
    # For example, if the field is on a "zen:user", it references a field on a user
    # + return - Success response
    resource isolated function get api/v2/organizations/autocomplete(string name, string accept = "application/json", string? field_id = (), string? 'source = ()) returns OrganizationsResponse|error {
        string resourcePath = string `/api/v2/organizations/autocomplete`;
        map<anydata> queryParam = {"name": name, "field_id": field_id, "source": 'source};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        OrganizationsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Count Organizations
    #
    # + return - Success response
    resource isolated function get api/v2/organizations/count() returns CountOrganizationResponse|error {
        string resourcePath = string `/api/v2/organizations/count`;
        CountOrganizationResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Many Organizations
    #
    # + return - Success response
    resource isolated function post api/v2/organizations/create_many() returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/organizations/create_many`;
        http:Request request = new;
        JobStatusResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Create Or Update Organization
    #
    # + return - Success response
    resource isolated function post api/v2/organizations/create_or_update() returns OrganizationResponse|error {
        string resourcePath = string `/api/v2/organizations/create_or_update`;
        http:Request request = new;
        OrganizationResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Bulk Delete Organizations
    #
    # + ids - A list of organization ids
    # + external_ids - A list of external ids
    # + return - Success response
    resource isolated function delete api/v2/organizations/destroy_many(string accept = "application/json", string? ids = (), string? external_ids = ()) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/organizations/destroy_many`;
        map<anydata> queryParam = {"ids": ids, "external_ids": external_ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        JobStatusResponse response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Search Organizations
    #
    # + external_id - The external id of an organization
    # + name - The name of an organization
    # + return - Success response
    resource isolated function get api/v2/organizations/search(string accept = "application/json", int? external_id = (), string? name = ()) returns OrganizationsResponse|error {
        string resourcePath = string `/api/v2/organizations/search`;
        map<anydata> queryParam = {"external_id": external_id, "name": name};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        OrganizationsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Show Many Organizations
    #
    # + ids - A list of organization ids
    # + external_ids - A list of external ids
    # + return - Success response
    resource isolated function get api/v2/organizations/show_many(string accept = "application/json", string? ids = (), string? external_ids = ()) returns OrganizationsResponse|error {
        string resourcePath = string `/api/v2/organizations/show_many`;
        map<anydata> queryParam = {"ids": ids, "external_ids": external_ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        OrganizationsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Many Organizations
    #
    # + ids - A list of organization ids
    # + external_ids - A list of external ids
    # + return - Success response
    resource isolated function put api/v2/organizations/update_many(string accept = "application/json", string? ids = (), string? external_ids = ()) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/organizations/update_many`;
        map<anydata> queryParam = {"ids": ids, "external_ids": external_ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        JobStatusResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # List Ticket Problems
    #
    # + return - Successful response
    resource isolated function get api/v2/problems() returns ListTicketProblemsResponse|error {
        string resourcePath = string `/api/v2/problems`;
        ListTicketProblemsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Autocomplete Problems
    #
    # + text - The text to search for
    # + return - Successful response
    resource isolated function post api/v2/problems/autocomplete(Problems_autocomplete_body payload, string accept = "application/json", string? text = ()) returns ListTicketProblemsResponse|error {
        string resourcePath = string `/api/v2/problems/autocomplete`;
        map<anydata> queryParam = {"text": text};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        ListTicketProblemsResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Bulk Unregister Push Notification Devices
    #
    # + return - Successful response
    resource isolated function post api/v2/push_notification_devices/destroy_many(PushNotificationDevicesRequest payload) returns string|error {
        string resourcePath = string `/api/v2/push_notification_devices/destroy_many`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        string response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # List queues
    #
    # + return - Success response
    resource isolated function get api/v2/queues() returns QueuesResponse|error {
        string resourcePath = string `/api/v2/queues`;
        QueuesResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create queue
    #
    # + return - Created response
    resource isolated function post api/v2/queues() returns QueueResponse|error {
        string resourcePath = string `/api/v2/queues`;
        http:Request request = new;
        QueueResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Queue
    #
    # + queue_id - The id of the omnichannel routing queue
    # + return - Success response
    resource isolated function get api/v2/queues/[string queue_id](string accept = "application/json") returns QueueResponse|error {
        string resourcePath = string `/api/v2/queues/${getEncodedUri(queue_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        QueueResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update queue
    #
    # + queue_id - The id of the omnichannel routing queue
    # + return - Success response
    resource isolated function put api/v2/queues/[string queue_id](string accept = "application/json") returns QueueResponse|error {
        string resourcePath = string `/api/v2/queues/${getEncodedUri(queue_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        QueueResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete queue
    #
    # + queue_id - The id of the omnichannel routing queue
    # + return - No content response
    resource isolated function delete api/v2/queues/[string queue_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/queues/${getEncodedUri(queue_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # List queue definitions
    #
    # + return - Success response
    resource isolated function get api/v2/queues/definitions() returns DefinitionsResponse|error {
        string resourcePath = string `/api/v2/queues/definitions`;
        DefinitionsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List Support Addresses
    #
    # + return - Success response
    resource isolated function get api/v2/recipient_addresses() returns SupportAddressesResponse|error {
        string resourcePath = string `/api/v2/recipient_addresses`;
        SupportAddressesResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Support Address
    #
    # + return - Created response
    resource isolated function post api/v2/recipient_addresses() returns SupportAddressResponse|error {
        string resourcePath = string `/api/v2/recipient_addresses`;
        http:Request request = new;
        SupportAddressResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Support Address
    #
    # + support_address_id - The ID of the support address
    # + return - Success response
    resource isolated function get api/v2/recipient_addresses/[int support_address_id](string accept = "application/json") returns SupportAddressResponse|error {
        string resourcePath = string `/api/v2/recipient_addresses/${getEncodedUri(support_address_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SupportAddressResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Support Address
    #
    # + support_address_id - The ID of the support address
    # + return - Success response
    resource isolated function put api/v2/recipient_addresses/[int support_address_id](string accept = "application/json") returns SupportAddressResponse|error {
        string resourcePath = string `/api/v2/recipient_addresses/${getEncodedUri(support_address_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        SupportAddressResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Support Address
    #
    # + support_address_id - The ID of the support address
    # + return - No Content response
    resource isolated function delete api/v2/recipient_addresses/[int support_address_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/recipient_addresses/${getEncodedUri(support_address_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Verify Support Address Forwarding
    #
    # + support_address_id - The ID of the support address
    # + return - Success response
    resource isolated function put api/v2/recipient_addresses/[int support_address_id]/verify(string accept = "application/json") returns string|error {
        string resourcePath = string `/api/v2/recipient_addresses/${getEncodedUri(support_address_id)}/verify`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        string response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Filter Definitions
    #
    # + target_type - The target type for which you would like to see filter definitions.
    # The options are "zen:user", "zen:ticket", "zen:organization", and "zen:custom_object:CUSTOM_OBJECT_KEY"
    # + source_type - The source type for which you would like to see filter definitions.
    # The options are "zen:user", "zen:ticket", and "zen:organization"
    # + return - Success response
    resource isolated function get api/v2/relationships/definitions/[string target_type](string accept = "application/json", string? source_type = ()) returns RelationshipFilterDefinitionResponse|error {
        string resourcePath = string `/api/v2/relationships/definitions/${getEncodedUri(target_type)}`;
        map<anydata> queryParam = {"source_type": source_type};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        RelationshipFilterDefinitionResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Requests
    #
    # + sort_by - Possible values are "updated_at", "created_at"
    # + sort_order - One of "asc", "desc". Defaults to "asc"
    # + return - Success response
    resource isolated function get api/v2/requests(string accept = "application/json", string? sort_by = (), string? sort_order = ()) returns RequestsResponse|error {
        string resourcePath = string `/api/v2/requests`;
        map<anydata> queryParam = {"sort_by": sort_by, "sort_order": sort_order};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        RequestsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Request
    #
    # + return - Created response
    resource isolated function post api/v2/requests() returns RequestResponse|error {
        string resourcePath = string `/api/v2/requests`;
        http:Request request = new;
        RequestResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Request
    #
    # + request_id - The ID of the request
    # + return - Success response
    resource isolated function get api/v2/requests/[int request_id](string accept = "application/json") returns RequestResponse|error {
        string resourcePath = string `/api/v2/requests/${getEncodedUri(request_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        RequestResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Request
    #
    # + request_id - The ID of the request
    # + return - Success response
    resource isolated function put api/v2/requests/[int request_id](string accept = "application/json") returns RequestResponse|error {
        string resourcePath = string `/api/v2/requests/${getEncodedUri(request_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        RequestResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Listing Comments
    #
    # + request_id - The ID of the request
    # + since - Filters the comments from the given datetime
    # + role - One of "agent", "end_user". If not specified it does not filter
    # + return - Success response
    resource isolated function get api/v2/requests/[int request_id]/comments(string accept = "application/json", string? since = (), string? role = ()) returns TicketCommentsResponse|error {
        string resourcePath = string `/api/v2/requests/${getEncodedUri(request_id)}/comments`;
        map<anydata> queryParam = {"since": since, "role": role};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketCommentsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Getting Comments
    #
    # + request_id - The ID of the request
    # + ticket_comment_id - The ID of the ticket comment
    # + return - Success response
    resource isolated function get api/v2/requests/[int request_id]/comments/[int ticket_comment_id](string accept = "application/json") returns TicketCommentResponse|error {
        string resourcePath = string `/api/v2/requests/${getEncodedUri(request_id)}/comments/${getEncodedUri(ticket_comment_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketCommentResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Search Requests
    #
    # + query - The syntax and matching logic for the string is detailed in the [Zendesk Support search reference](https://support.zendesk.com/hc/en-us/articles/203663226). See also [Query basics](/api-reference/ticketing/ticket-management/search/#query-basics) in the Tickets API doc.
    # + return - Success response
    resource isolated function get api/v2/requests/search(string accept = "application/json", string? query = ()) returns RequestsResponse|error {
        string resourcePath = string `/api/v2/requests/search`;
        map<anydata> queryParam = {"query": query};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        RequestsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Resource Collections
    #
    # + return - Success response
    resource isolated function get api/v2/resource_collections() returns ResourceCollectionsResponse|error {
        string resourcePath = string `/api/v2/resource_collections`;
        ResourceCollectionsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Resource Collection
    #
    # + return - Success response
    resource isolated function post api/v2/resource_collections() returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/resource_collections`;
        http:Request request = new;
        JobStatusResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Resource Collection
    #
    # + resource_collection_id - The id of the resource collection
    # + return - Success response
    resource isolated function get api/v2/resource_collections/[int resource_collection_id](string accept = "application/json") returns ResourceCollectionResponse|error {
        string resourcePath = string `/api/v2/resource_collections/${getEncodedUri(resource_collection_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ResourceCollectionResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Resource Collection
    #
    # + resource_collection_id - The id of the resource collection
    # + return - Success response
    resource isolated function put api/v2/resource_collections/[int resource_collection_id](string accept = "application/json") returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/resource_collections/${getEncodedUri(resource_collection_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        JobStatusResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Resource Collection
    #
    # + resource_collection_id - The id of the resource collection
    # + return - Success response
    resource isolated function delete api/v2/resource_collections/[int resource_collection_id](string accept = "application/json") returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/resource_collections/${getEncodedUri(resource_collection_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        JobStatusResponse response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # List Agent Attribute Values
    #
    # + user_id - The id of the user
    # + return - Success response
    resource isolated function get api/v2/routing/agents/[int user_id]/instance_values(string accept = "application/json") returns SkillBasedRoutingAttributeValuesResponse|error {
        string resourcePath = string `/api/v2/routing/agents/${getEncodedUri(user_id)}/instance_values`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SkillBasedRoutingAttributeValuesResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Set Agent Attribute Values
    #
    # + user_id - The id of the user
    # + return - Success response
    resource isolated function post api/v2/routing/agents/[int user_id]/instance_values(string accept = "application/json") returns SkillBasedRoutingAttributeValuesResponse|error {
        string resourcePath = string `/api/v2/routing/agents/${getEncodedUri(user_id)}/instance_values`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        SkillBasedRoutingAttributeValuesResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # List Account Attributes
    #
    # + return - Success response
    resource isolated function get api/v2/routing/attributes() returns SkillBasedRoutingAttributesResponse|error {
        string resourcePath = string `/api/v2/routing/attributes`;
        SkillBasedRoutingAttributesResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Attribute
    #
    # + return - Created response
    resource isolated function post api/v2/routing/attributes() returns SkillBasedRoutingAttributeResponse|error {
        string resourcePath = string `/api/v2/routing/attributes`;
        http:Request request = new;
        SkillBasedRoutingAttributeResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Attribute
    #
    # + attribute_id - The ID of the skill-based routing attribute
    # + return - Success response
    resource isolated function get api/v2/routing/attributes/[string attribute_id](string accept = "application/json") returns SkillBasedRoutingAttributeResponse|error {
        string resourcePath = string `/api/v2/routing/attributes/${getEncodedUri(attribute_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SkillBasedRoutingAttributeResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Attribute
    #
    # + attribute_id - The ID of the skill-based routing attribute
    # + return - Success response
    resource isolated function put api/v2/routing/attributes/[string attribute_id](string accept = "application/json") returns SkillBasedRoutingAttributeResponse|error {
        string resourcePath = string `/api/v2/routing/attributes/${getEncodedUri(attribute_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        SkillBasedRoutingAttributeResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Attribute
    #
    # + attribute_id - The ID of the skill-based routing attribute
    # + return - No Content response
    resource isolated function delete api/v2/routing/attributes/[string attribute_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/routing/attributes/${getEncodedUri(attribute_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # List Attribute Values for an Attribute
    #
    # + attribute_id - The ID of the skill-based routing attribute
    # + return - Success response
    resource isolated function get api/v2/routing/attributes/[string attribute_id]/values(string accept = "application/json") returns SkillBasedRoutingAttributeValuesResponse|error {
        string resourcePath = string `/api/v2/routing/attributes/${getEncodedUri(attribute_id)}/values`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SkillBasedRoutingAttributeValuesResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Attribute Value
    #
    # + attribute_id - The ID of the skill-based routing attribute
    # + return - Created response
    resource isolated function post api/v2/routing/attributes/[string attribute_id]/values(string accept = "application/json") returns SkillBasedRoutingAttributeValueResponse|error {
        string resourcePath = string `/api/v2/routing/attributes/${getEncodedUri(attribute_id)}/values`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        SkillBasedRoutingAttributeValueResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Show Attribute Value
    #
    # + attribute_id - The ID of the skill-based routing attribute
    # + attribute_value_id - The ID of the skill-based routing attribute value
    # + return - Success response
    resource isolated function get api/v2/routing/attributes/[string attribute_id]/values/[string attribute_value_id](string accept = "application/json") returns SkillBasedRoutingAttributeValueResponse|error {
        string resourcePath = string `/api/v2/routing/attributes/${getEncodedUri(attribute_id)}/values/${getEncodedUri(attribute_value_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SkillBasedRoutingAttributeValueResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Delete Attribute Value
    #
    # + attribute_id - The ID of the skill-based routing attribute
    # + attribute_value_id - The ID of the skill-based routing attribute value
    # + return - No Content response
    resource isolated function delete api/v2/routing/attributes/[string attribute_id]/values/[string attribute_value_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/routing/attributes/${getEncodedUri(attribute_id)}/values/${getEncodedUri(attribute_value_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Update Attribute Value
    #
    # + attribute_id - The ID of the skill-based routing attribute
    # + attribute_value_id - The ID of the skill-based routing attribute value
    # + return - Success response
    resource isolated function patch api/v2/routing/attributes/[string attribute_id]/values/[string attribute_value_id](string accept = "application/json") returns SkillBasedRoutingAttributeValueResponse|error {
        string resourcePath = string `/api/v2/routing/attributes/${getEncodedUri(attribute_id)}/values/${getEncodedUri(attribute_value_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        SkillBasedRoutingAttributeValueResponse response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # List Routing Attribute Definitions
    #
    # + return - Success response
    resource isolated function get api/v2/routing/attributes/definitions() returns SkillBasedRoutingAttributeDefinitions|error {
        string resourcePath = string `/api/v2/routing/attributes/definitions`;
        SkillBasedRoutingAttributeDefinitions response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List Tickets Fulfilled by a User
    #
    # + ticket_ids - The IDs of the relevant tickets to check for matching attributes
    # + return - Success response
    resource isolated function get api/v2/routing/requirements/fulfilled(int ticket_ids, string accept = "application/json") returns SkillBasedRoutingTicketFulfilledResponse|error {
        string resourcePath = string `/api/v2/routing/requirements/fulfilled`;
        map<anydata> queryParam = {"ticket_ids": ticket_ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SkillBasedRoutingTicketFulfilledResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Ticket Attribute Values
    #
    # + ticket_id - The ID of the ticket
    # + return - Success response
    resource isolated function get api/v2/routing/tickets/[int ticket_id]/instance_values(string accept = "application/json") returns SkillBasedRoutingAttributeValuesResponse|error {
        string resourcePath = string `/api/v2/routing/tickets/${getEncodedUri(ticket_id)}/instance_values`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SkillBasedRoutingAttributeValuesResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Set Ticket Attribute Values
    #
    # + ticket_id - The ID of the ticket
    # + return - Success response
    resource isolated function post api/v2/routing/tickets/[int ticket_id]/instance_values(string accept = "application/json") returns SkillBasedRoutingAttributeValuesResponse|error {
        string resourcePath = string `/api/v2/routing/tickets/${getEncodedUri(ticket_id)}/instance_values`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        SkillBasedRoutingAttributeValuesResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # List Satisfaction Ratings
    #
    # + return - Success response
    resource isolated function get api/v2/satisfaction_ratings(string accept = "application/json") returns SatisfactionRatingsResponse|error {
        string resourcePath = string `/api/v2/satisfaction_ratings`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SatisfactionRatingsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Show Satisfaction Rating
    #
    # + satisfaction_rating_id - The id of the satisfaction rating to retrieve
    # + return - Success response
    resource isolated function get api/v2/satisfaction_ratings/[int satisfaction_rating_id](string accept = "application/json") returns SatisfactionRatingResponse|error {
        string resourcePath = string `/api/v2/satisfaction_ratings/${getEncodedUri(satisfaction_rating_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SatisfactionRatingResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Count Satisfaction Ratings
    #
    # + return - Count of satisfaction ratings
    resource isolated function get api/v2/satisfaction_ratings/count() returns SatisfactionRatingsCountResponse|error {
        string resourcePath = string `/api/v2/satisfaction_ratings/count`;
        SatisfactionRatingsCountResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List Reasons for Satisfaction Rating
    #
    # + return - Success response
    resource isolated function get api/v2/satisfaction_reasons() returns SatisfactionReasonsResponse|error {
        string resourcePath = string `/api/v2/satisfaction_reasons`;
        SatisfactionReasonsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Show Reason for Satisfaction Rating
    #
    # + satisfaction_reason_id - The id of the satisfaction rating reason
    # + return - Success response
    resource isolated function get api/v2/satisfaction_reasons/[int satisfaction_reason_id](string accept = "application/json") returns SatisfactionReasonResponse|error {
        string resourcePath = string `/api/v2/satisfaction_reasons/${getEncodedUri(satisfaction_reason_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SatisfactionReasonResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Search Results
    #
    # + query - The search query. See [Query basics](#query-basics) above. For details on the query syntax, see the [Zendesk Support search reference](https://support.zendesk.com/hc/en-us/articles/203663226)
    # + sort_by - One of `updated_at`, `created_at`, `priority`, `status`, or `ticket_type`. Defaults to sorting by relevance
    # + sort_order - One of `asc` or `desc`.  Defaults to `desc`
    # + return - Success response
    resource isolated function get api/v2/search(string query, string accept = "application/json", string? sort_by = (), string? sort_order = ()) returns SearchResponse|error {
        string resourcePath = string `/api/v2/search`;
        map<anydata> queryParam = {"query": query, "sort_by": sort_by, "sort_order": sort_order};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SearchResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Show Results Count
    #
    # + query - The search query
    # + return - Success response
    resource isolated function get api/v2/search/count(string query, string accept = "application/json") returns SearchCountResponse|error {
        string resourcePath = string `/api/v2/search/count`;
        map<anydata> queryParam = {"query": query};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SearchCountResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Export Search Results
    #
    # + query - The search query. See [Query basics](#query-basics) above. For details on the query syntax, see the [Zendesk Support search reference](https://support.zendesk.com/hc/en-us/articles/203663226)
    # + pageSize - The number of results shown in a page.
    # + filterType - The object type returned by the export query. Can be `ticket`, `organization`, `user`, or `group`.
    # + return - Success response
    resource isolated function get api/v2/search/export(string query, string accept = "application/json", int? pageSize = (), string? filterType = ()) returns SearchExportResponse|error {
        string resourcePath = string `/api/v2/search/export`;
        map<anydata> queryParam = {"query": query, "page[size]": pageSize, "filter[type]": filterType};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SearchExportResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Sessions
    #
    # + user_id - The id of the user
    # + return - Success response
    resource isolated function get api/v2/sessions(string accept = "application/json") returns SessionsResponse|error {
        string resourcePath = string `/api/v2/sessions`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SessionsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Sharing Agreements
    #
    # + return - Success response
    resource isolated function get api/v2/sharing_agreements() returns SharingAgreementsResponse|error {
        string resourcePath = string `/api/v2/sharing_agreements`;
        SharingAgreementsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Sharing Agreement
    #
    # + return - Created response
    resource isolated function post api/v2/sharing_agreements() returns SharingAgreementResponse|error {
        string resourcePath = string `/api/v2/sharing_agreements`;
        http:Request request = new;
        SharingAgreementResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show a Sharing Agreement
    #
    # + sharing_agreement_id - The ID of the sharing agreement
    # + return - Success response
    resource isolated function get api/v2/sharing_agreements/[int sharing_agreement_id](string accept = "application/json") returns SharingAgreementResponse|error {
        string resourcePath = string `/api/v2/sharing_agreements/${getEncodedUri(sharing_agreement_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SharingAgreementResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update a Sharing Agreement
    #
    # + sharing_agreement_id - The ID of the sharing agreement
    # + return - Success response
    resource isolated function put api/v2/sharing_agreements/[int sharing_agreement_id](string accept = "application/json") returns SharingAgreementResponse|error {
        string resourcePath = string `/api/v2/sharing_agreements/${getEncodedUri(sharing_agreement_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        SharingAgreementResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete a Sharing Agreement
    #
    # + sharing_agreement_id - The ID of the sharing agreement
    # + return - No Content response
    resource isolated function delete api/v2/sharing_agreements/[int sharing_agreement_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/sharing_agreements/${getEncodedUri(sharing_agreement_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Record a New Skip for the Current User
    #
    # + return - Success response
    resource isolated function post api/v2/skips() returns TicketSkipCreation|error {
        string resourcePath = string `/api/v2/skips`;
        http:Request request = new;
        TicketSkipCreation response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # List SLA Policies
    #
    # + return - Success response
    resource isolated function get api/v2/slas/policies() returns SLAPoliciesResponse|error {
        string resourcePath = string `/api/v2/slas/policies`;
        SLAPoliciesResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create SLA Policy
    #
    # + return - Created response
    resource isolated function post api/v2/slas/policies() returns SLAPolicyResponse|error {
        string resourcePath = string `/api/v2/slas/policies`;
        http:Request request = new;
        SLAPolicyResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show SLA Policy
    #
    # + sla_policy_id - The ID of the SLA Policy
    # + return - Success response
    resource isolated function get api/v2/slas/policies/[int sla_policy_id](string accept = "application/json") returns SLAPolicyResponse|error {
        string resourcePath = string `/api/v2/slas/policies/${getEncodedUri(sla_policy_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SLAPolicyResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update SLA Policy
    #
    # + sla_policy_id - The ID of the SLA Policy
    # + return - Success response
    resource isolated function put api/v2/slas/policies/[int sla_policy_id](string accept = "application/json") returns SLAPolicyResponse|error {
        string resourcePath = string `/api/v2/slas/policies/${getEncodedUri(sla_policy_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        SLAPolicyResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete SLA Policy
    #
    # + sla_policy_id - The ID of the SLA Policy
    # + return - No Content response
    resource isolated function delete api/v2/slas/policies/[int sla_policy_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/slas/policies/${getEncodedUri(sla_policy_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Retrieve Supported Filter Definition Items
    #
    # + return - Success response
    resource isolated function get api/v2/slas/policies/definitions() returns SLAPolicyFilterDefinitionResponse|error {
        string resourcePath = string `/api/v2/slas/policies/definitions`;
        SLAPolicyFilterDefinitionResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Reorder SLA Policies
    #
    # + sla_policy_ids - The IDs of the SLA Policies to reorder
    # + return - Success response
    resource isolated function put api/v2/slas/policies/reorder(string accept = "application/json", int[]? sla_policy_ids = ()) returns string|error {
        string resourcePath = string `/api/v2/slas/policies/reorder`;
        map<anydata> queryParam = {"sla_policy_ids": sla_policy_ids};
        map<Encoding> queryParamEncoding = {"sla_policy_ids": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam, queryParamEncoding);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        string response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # List Suspended Tickets
    #
    # + sort_by - The field to sort the ticket by, being one of `author_email`, `cause`, `created_at`, or `subject`.
    # + sort_order - The order in which to sort the suspended tickets.  This can take value `asc` or `desc`.
    # + return - Success response
    resource isolated function get api/v2/suspended_tickets(string accept = "application/json", string? sort_by = (), string? sort_order = ()) returns SuspendedTicketsResponse|error {
        string resourcePath = string `/api/v2/suspended_tickets`;
        map<anydata> queryParam = {"sort_by": sort_by, "sort_order": sort_order};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SuspendedTicketsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Show Suspended Ticket
    #
    # + id - id of the suspended ticket
    # + return - Success response
    resource isolated function get api/v2/suspended_tickets/[decimal id](string accept = "application/json") returns SuspendedTicketsResponse|error {
        string resourcePath = string `/api/v2/suspended_tickets/${getEncodedUri(id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SuspendedTicketsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Delete Suspended Ticket
    #
    # + id - id of the suspended ticket
    # + return - No Content response
    resource isolated function delete api/v2/suspended_tickets/[decimal id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/suspended_tickets/${getEncodedUri(id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Recover Suspended Ticket
    #
    # + id - id of the suspended ticket
    # + return - Success response
    resource isolated function put api/v2/suspended_tickets/[decimal id]/recover(string accept = "application/json") returns RecoverSuspendedTicketResponse|error {
        string resourcePath = string `/api/v2/suspended_tickets/${getEncodedUri(id)}/recover`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        RecoverSuspendedTicketResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Suspended Ticket Attachments
    #
    # + id - id of the suspended ticket
    # + return - Success response
    resource isolated function post api/v2/suspended_tickets/attachments(string accept = "application/json") returns SuspendedTicketsAttachmentsResponse|error {
        string resourcePath = string `/api/v2/suspended_tickets/attachments`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        SuspendedTicketsAttachmentsResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Multiple Suspended Tickets
    #
    # + ids - A comma separated list of ids of suspended tickets to delete.
    # + return - No Content response
    resource isolated function delete api/v2/suspended_tickets/destroy_many(string ids, string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/suspended_tickets/destroy_many`;
        map<anydata> queryParam = {"ids": ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Export Suspended Tickets
    #
    # + return - Ok
    resource isolated function post api/v2/suspended_tickets/export() returns SuspendedTicketsExportResponse|error {
        string resourcePath = string `/api/v2/suspended_tickets/export`;
        http:Request request = new;
        SuspendedTicketsExportResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Recover Multiple Suspended Tickets
    #
    # + ids - A comma separated list of ids of suspended tickets to recover.
    # + return - Success response
    resource isolated function put api/v2/suspended_tickets/recover_many(string ids, string accept = "application/json") returns RecoverSuspendedTicketsResponse|error {
        string resourcePath = string `/api/v2/suspended_tickets/recover_many`;
        map<anydata> queryParam = {"ids": ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        RecoverSuspendedTicketsResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # List Tags
    #
    # + return - Success response
    resource isolated function get api/v2/tags() returns TagsResponse|error {
        string resourcePath = string `/api/v2/tags`;
        TagsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Count Tags
    #
    # + return - Success response
    resource isolated function get api/v2/tags/count() returns TagCountResponse|error {
        string resourcePath = string `/api/v2/tags/count`;
        TagCountResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List Target Failures
    #
    # + return - Success response
    resource isolated function get api/v2/target_failures() returns TargetFailuresResponse|error {
        string resourcePath = string `/api/v2/target_failures`;
        TargetFailuresResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Show Target Failure
    #
    # + target_failure_id - The ID of the target failure
    # + return - Success response
    resource isolated function get api/v2/target_failures/[int target_failure_id](string accept = "application/json") returns TargetFailureResponse|error {
        string resourcePath = string `/api/v2/target_failures/${getEncodedUri(target_failure_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TargetFailureResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Targets
    #
    # + return - Success response
    resource isolated function get api/v2/targets() returns TargetsResponse|error {
        string resourcePath = string `/api/v2/targets`;
        TargetsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Target
    #
    # + return - Created response
    resource isolated function post api/v2/targets() returns TargetResponse|error {
        string resourcePath = string `/api/v2/targets`;
        http:Request request = new;
        TargetResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Target
    #
    # + target_id - The ID of the target
    # + return - Success response
    resource isolated function get api/v2/targets/[int target_id](string accept = "application/json") returns TargetResponse|error {
        string resourcePath = string `/api/v2/targets/${getEncodedUri(target_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TargetResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Target
    #
    # + target_id - The ID of the target
    # + return - Success response
    resource isolated function put api/v2/targets/[int target_id](string accept = "application/json") returns TargetResponse|error {
        string resourcePath = string `/api/v2/targets/${getEncodedUri(target_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        TargetResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Target
    #
    # + target_id - The ID of the target
    # + return - No Content response
    resource isolated function delete api/v2/targets/[int target_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/targets/${getEncodedUri(target_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # List All Ticket Audits
    #
    # + 'limit - Maximum number of results returned
    # + return - Success response
    resource isolated function get api/v2/ticket_audits(string accept = "application/json", int? 'limit = ()) returns TicketAuditsResponse|error {
        string resourcePath = string `/api/v2/ticket_audits`;
        map<anydata> queryParam = {"limit": 'limit};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketAuditsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Ticket Fields
    #
    # + locale - Forces the `title_in_portal` property to return a dynamic content variant for the specified locale.
    # Only accepts [active locale ids](/api-reference/ticketing/account-configuration/locales/#list-locales).
    # Example: `locale="de"`.
    # + creator - Displays the `creator_user_id` and `creator_app_name` properties. If the ticket field is created
    # by an app, `creator_app_name` is the name of the app and `creator_user_id` is `-1`. If the ticket field
    # is not created by an app, `creator_app_name` is null
    # + return - Success response
    resource isolated function get api/v2/ticket_fields(string accept = "application/json", string? locale = (), boolean? creator = ()) returns TicketFieldsResponse|error {
        string resourcePath = string `/api/v2/ticket_fields`;
        map<anydata> queryParam = {"locale": locale, "creator": creator};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketFieldsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Ticket Field
    #
    # + return - Created response
    resource isolated function post api/v2/ticket_fields() returns TicketFieldResponse|error {
        string resourcePath = string `/api/v2/ticket_fields`;
        http:Request request = new;
        TicketFieldResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Ticket Field
    #
    # + ticket_field_id - The ID of the ticket field
    # + creator - If true, displays the `creator_user_id` and `creator_app_name` properties. If the ticket field is created
    # by an app, `creator_app_name` is the name of the app and `creator_user_id` is `-1`. If the ticket field
    # is not created by an app, then `creator_app_name` is null
    # + return - Success response
    resource isolated function get api/v2/ticket_fields/[int ticket_field_id](string accept = "application/json", boolean? creator = ()) returns TicketFieldResponse|error {
        string resourcePath = string `/api/v2/ticket_fields/${getEncodedUri(ticket_field_id)}`;
        map<anydata> queryParam = {"creator": creator};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketFieldResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Ticket Field
    #
    # + ticket_field_id - The ID of the ticket field
    # + creator - If true, displays the `creator_user_id` and `creator_app_name` properties. If the ticket field is created
    # by an app, `creator_app_name` is the name of the app and `creator_user_id` is `-1`. If the ticket field
    # is not created by an app, then `creator_app_name` is null
    # + return - Success response
    resource isolated function put api/v2/ticket_fields/[int ticket_field_id](string accept = "application/json", boolean? creator = ()) returns TicketFieldResponse|error {
        string resourcePath = string `/api/v2/ticket_fields/${getEncodedUri(ticket_field_id)}`;
        map<anydata> queryParam = {"creator": creator};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        TicketFieldResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Ticket Field
    #
    # + ticket_field_id - The ID of the ticket field
    # + creator - If true, displays the `creator_user_id` and `creator_app_name` properties. If the ticket field is created
    # by an app, `creator_app_name` is the name of the app and `creator_user_id` is `-1`. If the ticket field
    # is not created by an app, then `creator_app_name` is null
    # + return - No Content response
    resource isolated function delete api/v2/ticket_fields/[int ticket_field_id](string accept = "application/json", boolean? creator = ()) returns error? {
        string resourcePath = string `/api/v2/ticket_fields/${getEncodedUri(ticket_field_id)}`;
        map<anydata> queryParam = {"creator": creator};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # List Ticket Field Options
    #
    # + ticket_field_id - The ID of the ticket field
    # + return - Success response
    resource isolated function get api/v2/ticket_fields/[int ticket_field_id]/options(string accept = "application/json") returns CustomFieldOptionsResponse|error {
        string resourcePath = string `/api/v2/ticket_fields/${getEncodedUri(ticket_field_id)}/options`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CustomFieldOptionsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create or Update Ticket Field Option
    #
    # + ticket_field_id - The ID of the ticket field
    # + return - Success response
    resource isolated function post api/v2/ticket_fields/[int ticket_field_id]/options(string accept = "application/json") returns CustomFieldOptionResponse|error {
        string resourcePath = string `/api/v2/ticket_fields/${getEncodedUri(ticket_field_id)}/options`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        CustomFieldOptionResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Show Ticket Field Option
    #
    # + ticket_field_id - The ID of the ticket field
    # + ticket_field_option_id - The ID of the ticket field option
    # + return - Success response
    resource isolated function get api/v2/ticket_fields/[int ticket_field_id]/options/[int ticket_field_option_id](string accept = "application/json") returns CustomFieldOptionResponse|error {
        string resourcePath = string `/api/v2/ticket_fields/${getEncodedUri(ticket_field_id)}/options/${getEncodedUri(ticket_field_option_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CustomFieldOptionResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Delete Ticket Field Option
    #
    # + ticket_field_id - The ID of the ticket field
    # + ticket_field_option_id - The ID of the ticket field option
    # + return - No Content response
    resource isolated function delete api/v2/ticket_fields/[int ticket_field_id]/options/[int ticket_field_option_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/ticket_fields/${getEncodedUri(ticket_field_id)}/options/${getEncodedUri(ticket_field_option_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Count Ticket Fields
    #
    # + return - Count of ticket fields
    resource isolated function get api/v2/ticket_fields/count() returns TicketFieldCountResponse|error {
        string resourcePath = string `/api/v2/ticket_fields/count`;
        TicketFieldCountResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # List Ticket Forms
    #
    # + active - true returns active ticket forms; false returns inactive ticket forms. If not present, returns both
    # + end_user_visible - true returns ticket forms where `end_user_visible`; false returns ticket forms that are not end-user visible. If not present, returns both
    # + fallback_to_default - true returns the default ticket form when the criteria defined by the parameters results in a set without active and end-user visible ticket forms
    # + associated_to_brand - true returns the ticket forms of the brand specified by the url's subdomain
    # + return - Success response
    resource isolated function get api/v2/ticket_forms(string accept = "application/json", boolean? active = (), boolean? end_user_visible = (), boolean? fallback_to_default = (), boolean? associated_to_brand = ()) returns TicketFormsResponse|error {
        string resourcePath = string `/api/v2/ticket_forms`;
        map<anydata> queryParam = {"active": active, "end_user_visible": end_user_visible, "fallback_to_default": fallback_to_default, "associated_to_brand": associated_to_brand};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketFormsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Ticket Form
    #
    # + return - Created response
    resource isolated function post api/v2/ticket_forms() returns TicketFormResponse|error {
        string resourcePath = string `/api/v2/ticket_forms`;
        http:Request request = new;
        TicketFormResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Ticket Form
    #
    # + ticket_form_id - The ID of the ticket form
    # + return - Success response
    resource isolated function get api/v2/ticket_forms/[int ticket_form_id](string accept = "application/json") returns TicketFormResponse|error {
        string resourcePath = string `/api/v2/ticket_forms/${getEncodedUri(ticket_form_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketFormResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Ticket Form
    #
    # + ticket_form_id - The ID of the ticket form
    # + return - Success response
    resource isolated function put api/v2/ticket_forms/[int ticket_form_id](string accept = "application/json") returns TicketFormResponse|error {
        string resourcePath = string `/api/v2/ticket_forms/${getEncodedUri(ticket_form_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        TicketFormResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Ticket Form
    #
    # + ticket_form_id - The ID of the ticket form
    # + return - No Content response
    resource isolated function delete api/v2/ticket_forms/[int ticket_form_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/ticket_forms/${getEncodedUri(ticket_form_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Clone an Already Existing Ticket Form
    #
    # + ticket_form_id - The ID of the ticket form
    # + return - Success response
    resource isolated function post api/v2/ticket_forms/[int ticket_form_id]/clone(string accept = "application/json") returns TicketFormResponse|error {
        string resourcePath = string `/api/v2/ticket_forms/${getEncodedUri(ticket_form_id)}/clone`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        TicketFormResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Reorder Ticket Forms
    #
    # + return - Success response
    resource isolated function put api/v2/ticket_forms/reorder() returns TicketFormsResponse|error {
        string resourcePath = string `/api/v2/ticket_forms/reorder`;
        http:Request request = new;
        TicketFormsResponse response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Show Many Ticket Forms
    #
    # + ids - IDs of the ticket forms to be shown
    # + active - true returns active ticket forms; false returns inactive ticket forms. If not present, returns both
    # + end_user_visible - true returns ticket forms where `end_user_visible`; false returns ticket forms that are not end-user visible. If not present, returns both
    # + fallback_to_default - true returns the default ticket form when the criteria defined by the parameters results in a set without active and end-user visible ticket forms
    # + associated_to_brand - true returns the ticket forms of the brand specified by the url's subdomain
    # + return - Success response
    resource isolated function get api/v2/ticket_forms/show_many(string ids, string accept = "application/json", boolean? active = (), boolean? end_user_visible = (), boolean? fallback_to_default = (), boolean? associated_to_brand = ()) returns TicketFormsResponse|error {
        string resourcePath = string `/api/v2/ticket_forms/show_many`;
        map<anydata> queryParam = {"ids": ids, "active": active, "end_user_visible": end_user_visible, "fallback_to_default": fallback_to_default, "associated_to_brand": associated_to_brand};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketFormsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Ticket Metrics
    #
    # + return - Success response
    resource isolated function get api/v2/ticket_metrics() returns TicketMetricsResponse|error {
        string resourcePath = string `/api/v2/ticket_metrics`;
        TicketMetricsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Show Ticket Metrics
    #
    # + ticket_metric_id - The id of the ticket metric to retrieve
    # + return - Success response
    resource isolated function get api/v2/ticket_metrics/[string ticket_metric_id](string accept = "application/json") returns TicketMetricsByTicketMetricIdResponse|error {
        string resourcePath = string `/api/v2/ticket_metrics/${getEncodedUri(ticket_metric_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketMetricsByTicketMetricIdResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Tickets
    #
    # + external_id - Lists tickets by external id. External ids don't have to be unique for each ticket. As a result, the request may return multiple tickets with the same external id.
    # + return - List tickets
    resource isolated function get api/v2/tickets(string accept = "application/json", string? external_id = ()) returns TicketsResponse|error {
        string resourcePath = string `/api/v2/tickets`;
        map<anydata> queryParam = {"external_id": external_id};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Ticket
    #
    # + return - Create ticket
    resource isolated function post api/v2/tickets(TicketCreateRequest payload) returns TicketResponse|error {
        string resourcePath = string `/api/v2/tickets`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        TicketResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Ticket
    #
    # + ticket_id - The ID of the ticket
    # + return - Ticket
    resource isolated function get api/v2/tickets/[int ticket_id](string accept = "application/json") returns TicketResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Ticket
    #
    # + ticket_id - The ID of the ticket
    # + return - Successful request
    resource isolated function put api/v2/tickets/[int ticket_id](TicketUpdateRequest payload, string accept = "application/json") returns TicketUpdateResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        TicketUpdateResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Ticket
    #
    # + ticket_id - The ID of the ticket
    # + return - No content
    resource isolated function delete api/v2/tickets/[int ticket_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # List Audits for a Ticket
    #
    # + ticket_id - The ID of the ticket
    # + return - OK response
    resource isolated function get api/v2/tickets/[int ticket_id]/audits(string accept = "application/json") returns TicketAuditsResponseNoneCursor|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/audits`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketAuditsResponseNoneCursor response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Show Audit
    #
    # + ticket_id - The ID of the ticket
    # + ticket_audit_id - The ID of the ticket audit
    # + return - OK response
    resource isolated function get api/v2/tickets/[int ticket_id]/audits/[int ticket_audit_id](string accept = "application/json") returns TicketAuditResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/audits/${getEncodedUri(ticket_audit_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketAuditResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Change a Comment From Public To Private
    #
    # + ticket_id - The ID of the ticket
    # + ticket_audit_id - The ID of the ticket audit
    # + return - description
    resource isolated function put api/v2/tickets/[int ticket_id]/audits/[int ticket_audit_id]/make_private(string accept = "application/json") returns string|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/audits/${getEncodedUri(ticket_audit_id)}/make_private`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        string response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Count Audits for a Ticket
    #
    # + ticket_id - The ID of the ticket
    # + return - Count of audits on a ticket
    resource isolated function get api/v2/tickets/[int ticket_id]/audits/count(string accept = "application/json") returns TicketAuditsCountResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/audits/count`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketAuditsCountResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Collaborators for a Ticket
    #
    # + ticket_id - The ID of the ticket
    # + return - Successful response
    resource isolated function get api/v2/tickets/[int ticket_id]/collaborators(string accept = "application/json") returns ListTicketCollaboratorsResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/collaborators`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ListTicketCollaboratorsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Comments
    #
    # + ticket_id - The ID of the ticket
    # + include_inline_images - Default is false. When true, inline images are also listed as attachments in the response
    # + include - Accepts "users". Use this parameter to list email CCs by side-loading users. Example: `?include=users`. **Note**: If the comment source is email, a deleted user will be represented as the CCd email address. If the comment source is anything else, a deleted user will be represented as the user name.
    # + return - Success response
    resource isolated function get api/v2/tickets/[int ticket_id]/comments(string accept = "application/json", boolean? include_inline_images = (), string? include = ()) returns TicketCommentsResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/comments`;
        map<anydata> queryParam = {"include_inline_images": include_inline_images, "include": include};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketCommentsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Redact Comment Attachment
    #
    # + ticket_id - The ID of the ticket
    # + comment_id - The ID of the comment
    # + attachment_id - The ID of the attachment
    # + return - OK response
    resource isolated function put api/v2/tickets/[int ticket_id]/comments/[int comment_id]/attachments/[int attachment_id]/redact(string accept = "application/json") returns AttachmentResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/comments/${getEncodedUri(comment_id)}/attachments/${getEncodedUri(attachment_id)}/redact`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        AttachmentResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Make Comment Private
    #
    # + ticket_id - The ID of the ticket
    # + ticket_comment_id - The ID of the ticket comment
    # + return - description
    resource isolated function put api/v2/tickets/[int ticket_id]/comments/[int ticket_comment_id]/make_private(string accept = "application/json") returns string|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/comments/${getEncodedUri(ticket_comment_id)}/make_private`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        string response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Redact String in Comment
    #
    # + ticket_id - The ID of the ticket
    # + ticket_comment_id - The ID of the ticket comment
    # + return - Success response
    resource isolated function put api/v2/tickets/[int ticket_id]/comments/[int ticket_comment_id]/redact(string accept = "application/json") returns TicketCommentResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/comments/${getEncodedUri(ticket_comment_id)}/redact`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        TicketCommentResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Count Ticket Comments
    #
    # + ticket_id - The ID of the ticket
    # + return - Count of ticket comments
    resource isolated function get api/v2/tickets/[int ticket_id]/comments/count(string accept = "application/json") returns TicketCommentsCountResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/comments/count`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketCommentsCountResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Email CCs for a Ticket
    #
    # + ticket_id - The ID of the ticket
    # + return - Successful response
    resource isolated function get api/v2/tickets/[int ticket_id]/email_ccs(string accept = "application/json") returns ListTicketEmailCCsResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/email_ccs`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ListTicketEmailCCsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Followers for a Ticket
    #
    # + ticket_id - The ID of the ticket
    # + return - Successful response
    resource isolated function get api/v2/tickets/[int ticket_id]/followers(string accept = "application/json") returns ListTicketFollowersResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/followers`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ListTicketFollowersResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Ticket Incidents
    #
    # + ticket_id - The ID of the ticket
    # + return - Successful response
    resource isolated function get api/v2/tickets/[int ticket_id]/incidents(string accept = "application/json") returns ListTicketIncidentsResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/incidents`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ListTicketIncidentsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Show Ticket After Changes
    #
    # + macro_id - The ID of the macro
    # + ticket_id - The ID of the ticket
    # + return - Success Response
    resource isolated function get api/v2/tickets/[int ticket_id]/macros/[int macro_id]/apply(string accept = "application/json") returns MacroApplyTicketResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/macros/${getEncodedUri(macro_id)}/apply`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        MacroApplyTicketResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Mark Ticket as Spam and Suspend Requester
    #
    # + ticket_id - The ID of the ticket
    # + return - Successful response
    resource isolated function put api/v2/tickets/[int ticket_id]/mark_as_spam(string accept = "application/json") returns string|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/mark_as_spam`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        string response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Merge Tickets into Target Ticket
    #
    # + ticket_id - The ID of the ticket
    # + return - Successful response
    resource isolated function post api/v2/tickets/[int ticket_id]/merge(TicketMergeInput payload, string accept = "application/json") returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/merge`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        JobStatusResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Ticket Related Information
    #
    # + ticket_id - The ID of the ticket
    # + return - Successful response
    resource isolated function get api/v2/tickets/[int ticket_id]/related(string accept = "application/json") returns TicketRelatedInformation|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/related`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketRelatedInformation response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create a Satisfaction Rating
    #
    # + ticket_id - The id of the ticket
    # + return - Success response
    resource isolated function post api/v2/tickets/[int ticket_id]/satisfaction_rating(string accept = "application/json") returns SatisfactionRatingResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/satisfaction_rating`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        SatisfactionRatingResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # List Resource Tags
    #
    # + ticket_id - The ID of the ticket
    # + return - Success response
    resource isolated function get api/v2/tickets/[int ticket_id]/tags(string accept = "application/json") returns TagsByObjectIdResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/tags`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TagsByObjectIdResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Add Tags
    #
    # + ticket_id - The ID of the ticket
    # + return - Success response
    resource isolated function put api/v2/tickets/[int ticket_id]/tags(string accept = "application/json") returns TagsByObjectIdResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/tags`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        TagsByObjectIdResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Set Tags
    #
    # + ticket_id - The ID of the ticket
    # + return - Created response
    resource isolated function post api/v2/tickets/[int ticket_id]/tags(string accept = "application/json") returns TagsByObjectIdResponse|error {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/tags`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        TagsByObjectIdResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Remove Tags
    #
    # + ticket_id - The ID of the ticket
    # + return - No Content response
    resource isolated function delete api/v2/tickets/[int ticket_id]/tags(string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/tickets/${getEncodedUri(ticket_id)}/tags`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Count Tickets
    #
    # + return - Count of tickets
    resource isolated function get api/v2/tickets/count() returns Inline_response_200_5|error {
        string resourcePath = string `/api/v2/tickets/count`;
        Inline_response_200_5 response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Many Tickets
    #
    # + return - Create many tickets
    resource isolated function post api/v2/tickets/create_many(TicketsCreateRequest payload) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/tickets/create_many`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        JobStatusResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Bulk Delete Tickets
    #
    # + ids - Comma-separated list of ticket ids
    # + return - Successful response
    resource isolated function delete api/v2/tickets/destroy_many(string ids, string accept = "application/json") returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/tickets/destroy_many`;
        map<anydata> queryParam = {"ids": ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        JobStatusResponse response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Bulk Mark Tickets as Spam
    #
    # + ids - Comma-separated list of ticket ids
    # + return - Successful response
    resource isolated function put api/v2/tickets/mark_many_as_spam(string ids, string accept = "application/json") returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/tickets/mark_many_as_spam`;
        map<anydata> queryParam = {"ids": ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        JobStatusResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Show Multiple Tickets
    #
    # + ids - Comma-separated list of ticket ids
    # + return - List tickets
    resource isolated function get api/v2/tickets/show_many(string ids, string accept = "application/json") returns TicketsResponse|error {
        string resourcePath = string `/api/v2/tickets/show_many`;
        map<anydata> queryParam = {"ids": ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Many Tickets
    #
    # + ids - Comma-separated list of ticket ids
    # + return - Successful response
    resource isolated function put api/v2/tickets/update_many(string accept = "application/json", string? ids = ()) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/tickets/update_many`;
        map<anydata> queryParam = {"ids": ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        JobStatusResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # List Trigger Categories
    #
    # + page - Pagination parameters
    # + sort - Sort parameters
    # + include - Allowed sideloads
    # + return - A paged array of trigger categories
    resource isolated function get api/v2/trigger_categories(string accept = "application/json", Page? page = (), "position"|"-position"|"name"|"-name"|"created_at"|"-created_at"|"updated_at"|"-updated_at"? sort = (), "rule_counts"? include = ()) returns Inline_response_200_6|error {
        string resourcePath = string `/api/v2/trigger_categories`;
        map<anydata> queryParam = {"page": page, "sort": sort, "include": include};
        map<Encoding> queryParamEncoding = {"page": {style: DEEPOBJECT, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam, queryParamEncoding);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Inline_response_200_6 response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Trigger Category
    #
    # + return - The created trigger category
    resource isolated function post api/v2/trigger_categories(V2_trigger_categories_body payload) returns TriggerCategoryResponse|error {
        string resourcePath = string `/api/v2/trigger_categories`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        TriggerCategoryResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Trigger Category
    #
    # + trigger_category_id - The id of the trigger category to retrieve
    # + return - The requested trigger category
    resource isolated function get api/v2/trigger_categories/[string trigger_category_id](string accept = "application/json") returns TriggerCategoryResponse|error {
        string resourcePath = string `/api/v2/trigger_categories/${getEncodedUri(trigger_category_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TriggerCategoryResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Delete Trigger Category
    #
    # + trigger_category_id - The id of the trigger category to delete
    # + return - No content
    resource isolated function delete api/v2/trigger_categories/[string trigger_category_id](string accept = "application/json") returns http:Response|error {
        string resourcePath = string `/api/v2/trigger_categories/${getEncodedUri(trigger_category_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Response response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Update Trigger Category
    #
    # + trigger_category_id - The id of the trigger category to update
    # + return - The updated trigger category
    resource isolated function patch api/v2/trigger_categories/[string trigger_category_id](Trigger_categories_trigger_category_id_body payload, string accept = "application/json") returns TriggerCategoryResponse|error {
        string resourcePath = string `/api/v2/trigger_categories/${getEncodedUri(trigger_category_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        TriggerCategoryResponse response = check self.clientEp->patch(resourcePath, request, httpHeaders);
        return response;
    }
    # Create Batch Job for Trigger Categories
    #
    # + return - The response to the batch job
    resource isolated function post api/v2/trigger_categories/jobs(BatchJobRequest payload) returns BatchJobResponse|error {
        string resourcePath = string `/api/v2/trigger_categories/jobs`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        BatchJobResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # List Triggers
    #
    # + active - Filter by active triggers if true or inactive triggers if false
    # + sort - Cursor-based pagination only. Possible values are "alphabetical", "created_at", "updated_at", or "position".
    # + sort_by - Offset pagination only. Possible values are "alphabetical", "created_at", "updated_at", "usage_1h", "usage_24h", or "usage_7d". Defaults to "position"
    # + sort_order - One of "asc" or "desc". Defaults to "asc" for alphabetical and position sort, "desc" for all others
    # + category_id - Filter triggers by category ID
    # + return - Success response
    resource isolated function get api/v2/triggers(string accept = "application/json", boolean? active = (), string? sort = (), string? sort_by = (), string? sort_order = (), string? category_id = ()) returns TriggersResponse|error {
        string resourcePath = string `/api/v2/triggers`;
        map<anydata> queryParam = {"active": active, "sort": sort, "sort_by": sort_by, "sort_order": sort_order, "category_id": category_id};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TriggersResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Trigger
    #
    # + return - Created response
    resource isolated function post api/v2/triggers(TriggerWithCategoryRequest payload) returns TriggerResponse|error {
        string resourcePath = string `/api/v2/triggers`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        TriggerResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Trigger
    #
    # + trigger_id - The ID of the trigger
    # + return - Success response
    resource isolated function get api/v2/triggers/[int trigger_id](string accept = "application/json") returns TriggerResponse|error {
        string resourcePath = string `/api/v2/triggers/${getEncodedUri(trigger_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TriggerResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Trigger
    #
    # + trigger_id - The ID of the trigger
    # + return - Success response
    resource isolated function put api/v2/triggers/[int trigger_id](TriggerWithCategoryRequest payload, string accept = "application/json") returns TriggerResponse|error {
        string resourcePath = string `/api/v2/triggers/${getEncodedUri(trigger_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        TriggerResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Trigger
    #
    # + trigger_id - The ID of the trigger
    # + return - No Content response
    resource isolated function delete api/v2/triggers/[int trigger_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/triggers/${getEncodedUri(trigger_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # List Trigger Revisions
    #
    # + trigger_id - The ID of the trigger
    # + return - Success response
    resource isolated function get api/v2/triggers/[int trigger_id]/revisions(string accept = "application/json") returns TriggerRevisionsResponse|error {
        string resourcePath = string `/api/v2/triggers/${getEncodedUri(trigger_id)}/revisions`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TriggerRevisionsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Show Trigger Revision
    #
    # + trigger_id - The ID of the trigger
    # + trigger_revision_id - The ID of the revision for a particular trigger
    # + return - Success response
    resource isolated function get api/v2/triggers/[int trigger_id]/revisions/[int trigger_revision_id](string accept = "application/json") returns TriggerRevisionResponse|error {
        string resourcePath = string `/api/v2/triggers/${getEncodedUri(trigger_id)}/revisions/${getEncodedUri(trigger_revision_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TriggerRevisionResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Active Triggers
    #
    # + sort - Cursor-based pagination only. Possible values are "alphabetical", "created_at", "updated_at", or "position".
    # + sort_by - Offset pagination only. Possible values are "alphabetical", "created_at", "updated_at", "usage_1h", "usage_24h", or "usage_7d". Defaults to "position"
    # + sort_order - One of "asc" or "desc". Defaults to "asc" for alphabetical and position sort, "desc" for all others
    # + category_id - Filter triggers by category ID
    # + return - Success response
    resource isolated function get api/v2/triggers/active(string accept = "application/json", string? sort = (), string? sort_by = (), string? sort_order = (), string? category_id = ()) returns TriggersResponse|error {
        string resourcePath = string `/api/v2/triggers/active`;
        map<anydata> queryParam = {"sort": sort, "sort_by": sort_by, "sort_order": sort_order, "category_id": category_id};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TriggersResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Trigger Action and Condition Definitions
    #
    # + return - Success response
    resource isolated function get api/v2/triggers/definitions() returns TriggerDefinitionResponse|error {
        string resourcePath = string `/api/v2/triggers/definitions`;
        TriggerDefinitionResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Bulk Delete Triggers
    #
    # + ids - A comma separated list of trigger IDs
    # + return - No content response
    resource isolated function delete api/v2/triggers/destroy_many(string ids, string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/triggers/destroy_many`;
        map<anydata> queryParam = {"ids": ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Reorder Triggers
    #
    # + return - Success response
    resource isolated function put api/v2/triggers/reorder() returns TriggerResponse|error {
        string resourcePath = string `/api/v2/triggers/reorder`;
        http:Request request = new;
        TriggerResponse response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Search Triggers
    #
    # + query - Query string used to find all triggers with matching title
    # + filter - Trigger attribute filters for the search. See [Filter](#filter)
    # + active - Filter by active triggers if true or inactive triggers if false
    # + sort - Cursor-based pagination only. Possible values are "alphabetical", "created_at", "updated_at", or "position".
    # + sort_by - Offset pagination only. Possible values are "alphabetical", "created_at", "updated_at", "usage_1h", "usage_24h", or "usage_7d". Defaults to "position"
    # + sort_order - One of "asc" or "desc". Defaults to "asc" for alphabetical and position sort, "desc" for all others
    # + include - A sideload to include in the response. See [Sideloads](#sideloads-2)
    # + return - Success response
    resource isolated function get api/v2/triggers/search(string query, string accept = "application/json", Filter? filter = (), boolean? active = (), string? sort = (), string? sort_by = (), string? sort_order = (), string? include = ()) returns TriggersResponse|error {
        string resourcePath = string `/api/v2/triggers/search`;
        map<anydata> queryParam = {"query": query, "filter": filter, "active": active, "sort": sort, "sort_by": sort_by, "sort_order": sort_order, "include": include};
        map<Encoding> queryParamEncoding = {"filter": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam, queryParamEncoding);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TriggersResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Many Triggers
    #
    # + return - Success response
    resource isolated function put api/v2/triggers/update_many(TriggerBulkUpdateRequest payload) returns TriggersResponse|error {
        string resourcePath = string `/api/v2/triggers/update_many`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        TriggersResponse response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # Upload Files
    #
    # + return - Created response
    resource isolated function post api/v2/uploads() returns AttachmentUploadResponse|error {
        string resourcePath = string `/api/v2/uploads`;
        http:Request request = new;
        AttachmentUploadResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Delete Upload
    #
    # + token - The token of the uploaded attachment
    # + return - No Content response
    resource isolated function delete api/v2/uploads/[string token](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/uploads/${getEncodedUri(token)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # List User Fields
    #
    # + return - Success response
    resource isolated function get api/v2/user_fields() returns UserFieldsResponse|error {
        string resourcePath = string `/api/v2/user_fields`;
        UserFieldsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create User Field
    #
    # + return - Created response
    resource isolated function post api/v2/user_fields() returns UserFieldResponse|error {
        string resourcePath = string `/api/v2/user_fields`;
        http:Request request = new;
        UserFieldResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show User Field
    #
    # + user_field_id - The ID or key of the user field
    # + return - Success response
    resource isolated function get api/v2/user_fields/[User_field_id user_field_id](string accept = "application/json") returns UserFieldResponse|error {
        string resourcePath = string `/api/v2/user_fields/${getEncodedUri(user_field_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        UserFieldResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update User Field
    #
    # + user_field_id - The ID or key of the user field
    # + return - Success response
    resource isolated function put api/v2/user_fields/[User_field_id user_field_id](string accept = "application/json") returns UserFieldResponse|error {
        string resourcePath = string `/api/v2/user_fields/${getEncodedUri(user_field_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        UserFieldResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete User Field
    #
    # + user_field_id - The ID or key of the user field
    # + return - No Content response
    resource isolated function delete api/v2/user_fields/[User_field_id user_field_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/user_fields/${getEncodedUri(user_field_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # List User Field Options
    #
    # + user_field_id - The ID or key of the user field
    # + return - Success response
    resource isolated function get api/v2/user_fields/[User_field_id user_field_id]/options(string accept = "application/json") returns CustomFieldOptionsResponse|error {
        string resourcePath = string `/api/v2/user_fields/${getEncodedUri(user_field_id)}/options`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CustomFieldOptionsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create or Update a User Field Option
    #
    # + user_field_id - The ID or key of the user field
    # + return - Success response
    resource isolated function post api/v2/user_fields/[User_field_id user_field_id]/options(string accept = "application/json") returns CustomFieldOptionResponse|error {
        string resourcePath = string `/api/v2/user_fields/${getEncodedUri(user_field_id)}/options`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        CustomFieldOptionResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Show a User Field Option
    #
    # + user_field_id - The ID or key of the user field
    # + user_field_option_id - The ID of the user field option
    # + return - Success response
    resource isolated function get api/v2/user_fields/[User_field_id user_field_id]/options/[int user_field_option_id](string accept = "application/json") returns CustomFieldOptionResponse|error {
        string resourcePath = string `/api/v2/user_fields/${getEncodedUri(user_field_id)}/options/${getEncodedUri(user_field_option_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CustomFieldOptionResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Delete User Field Option
    #
    # + user_field_id - The ID or key of the user field
    # + user_field_option_id - The ID of the user field option
    # + return - No Content response
    resource isolated function delete api/v2/user_fields/[User_field_id user_field_id]/options/[int user_field_option_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/user_fields/${getEncodedUri(user_field_id)}/options/${getEncodedUri(user_field_option_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Reorder User Field
    #
    # + return - Success response
    resource isolated function put api/v2/user_fields/reorder() returns string|error {
        string resourcePath = string `/api/v2/user_fields/reorder`;
        http:Request request = new;
        string response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # List Users
    #
    # + role - Filters the results by role. Possible values are "end-user", "agent", or "admin"
    # + roles - Filters the results by more than one role using the format `role[]={role}&role[]={role}`
    # + permission_set - For custom roles which is available on the Enterprise plan and above. You can only filter by one role ID per request
    # + external_id - List users by external id. External id has to be unique for each user under the same account.
    # + return - Success response
    resource isolated function get api/v2/users(string accept = "application/json", "end-user"|"agent"|"admin"? role = (), string? roles = (), int? permission_set = (), string? external_id = ()) returns UsersResponse|error {
        string resourcePath = string `/api/v2/users`;
        map<anydata> queryParam = {"role": role, "roles": roles, "permission_set": permission_set, "external_id": external_id};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        UsersResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create User
    #
    # + return - Created response
    resource isolated function post api/v2/users(UserRequest payload) returns UserResponse|error {
        string resourcePath = string `/api/v2/users`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        UserResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show User
    #
    # + user_id - The id of the user
    # + return - Success response
    resource isolated function get api/v2/users/[int user_id](string accept = "application/json") returns UserResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        UserResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update User
    #
    # + user_id - The id of the user
    # + return - Success response
    resource isolated function put api/v2/users/[int user_id](UserRequest payload, string accept = "application/json") returns UserResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        UserResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete User
    #
    # + user_id - The id of the user
    # + return - Success response
    resource isolated function delete api/v2/users/[int user_id](string accept = "application/json") returns UserResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        UserResponse response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Show Compliance Deletion Statuses
    #
    # + user_id - The id of the user
    # + application - Area of compliance
    # + return - Success response
    resource isolated function get api/v2/users/[int user_id]/compliance_deletion_statuses(string accept = "application/json", string? application = ()) returns ComplianceDeletionStatusesResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/compliance_deletion_statuses`;
        map<anydata> queryParam = {"application": application};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ComplianceDeletionStatusesResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Memberships
    #
    # + user_id - The id of the user
    # + return - Success response
    resource isolated function get api/v2/users/[int user_id]/group_memberships(string accept = "application/json") returns GroupMembershipsResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/group_memberships`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        GroupMembershipsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Set Membership as Default
    #
    # + user_id - The id of the user
    # + group_membership_id - The ID of the group membership
    # + return - Success response
    resource isolated function put api/v2/users/[int user_id]/group_memberships/[int group_membership_id]/make_default(string accept = "application/json") returns GroupMembershipsResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/group_memberships/${getEncodedUri(group_membership_id)}/make_default`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        GroupMembershipsResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # List Identities
    #
    # + user_id - The id of the user
    # + return - Success response
    resource isolated function get api/v2/users/[int user_id]/identities(string accept = "application/json") returns UserIdentitiesResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/identities`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        UserIdentitiesResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Identity
    #
    # + user_id - The id of the user
    # + return - Created response
    resource isolated function post api/v2/users/[int user_id]/identities(string accept = "application/json") returns UserIdentityResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/identities`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        UserIdentityResponse response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Show Identity
    #
    # + user_id - The id of the user
    # + user_identity_id - The ID of the user identity
    # + return - Success response
    resource isolated function get api/v2/users/[int user_id]/identities/[int user_identity_id](string accept = "application/json") returns UserIdentityResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/identities/${getEncodedUri(user_identity_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        UserIdentityResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Identity
    #
    # + user_id - The id of the user
    # + user_identity_id - The ID of the user identity
    # + return - Success response
    resource isolated function put api/v2/users/[int user_id]/identities/[int user_identity_id](string accept = "application/json") returns UserIdentityResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/identities/${getEncodedUri(user_identity_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        UserIdentityResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Identity
    #
    # + user_id - The id of the user
    # + user_identity_id - The ID of the user identity
    # + return - No Content response
    resource isolated function delete api/v2/users/[int user_id]/identities/[int user_identity_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/identities/${getEncodedUri(user_identity_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Make Identity Primary
    #
    # + user_id - The id of the user
    # + user_identity_id - The ID of the user identity
    # + return - Success response
    resource isolated function put api/v2/users/[int user_id]/identities/[int user_identity_id]/make_primary(string accept = "application/json") returns UserIdentitiesResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/identities/${getEncodedUri(user_identity_id)}/make_primary`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        UserIdentitiesResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Request User Verification
    #
    # + user_id - The id of the user
    # + user_identity_id - The ID of the user identity
    # + return - Success description
    resource isolated function put api/v2/users/[int user_id]/identities/[int user_identity_id]/request_verification(string accept = "application/json") returns string|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/identities/${getEncodedUri(user_identity_id)}/request_verification`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        string response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Verify Identity
    #
    # + user_id - The id of the user
    # + user_identity_id - The ID of the user identity
    # + return - Success response
    resource isolated function put api/v2/users/[int user_id]/identities/[int user_identity_id]/verify(string accept = "application/json") returns UserIdentityResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/identities/${getEncodedUri(user_identity_id)}/verify`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        UserIdentityResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Merge End Users
    #
    # + user_id - The id of the user
    # + return - Success response
    resource isolated function put api/v2/users/[int user_id]/merge(UserRequest payload, string accept = "application/json") returns UserResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/merge`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        UserResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Set Membership as Default
    #
    # + user_id - The id of the user
    # + organization_membership_id - The ID of the organization membership
    # + return - Success response
    resource isolated function put api/v2/users/[int user_id]/organization_memberships/[int organization_membership_id]/make_default(string accept = "application/json") returns OrganizationMembershipsResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/organization_memberships/${getEncodedUri(organization_membership_id)}/make_default`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        OrganizationMembershipsResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Unassign Organization
    #
    # + organization_id - The ID of an organization
    # + user_id - The id of the user
    # + return - No Content response
    resource isolated function delete api/v2/users/[int user_id]/organizations/[int organization_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/organizations/${getEncodedUri(organization_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Set Organization as Default
    #
    # + user_id - The id of the user
    # + organization_id - The ID of an organization
    # + return - Success response
    resource isolated function put api/v2/users/[int user_id]/organizations/[int organization_id]/make_default(string accept = "application/json") returns OrganizationMembershipResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/organizations/${getEncodedUri(organization_id)}/make_default`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        OrganizationMembershipResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Change Your Password
    #
    # + user_id - The id of the user
    # + return - Success description
    resource isolated function put api/v2/users/[int user_id]/password(string accept = "application/json") returns string|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/password`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        string response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Set a User's Password
    #
    # + user_id - The id of the user
    # + return - Success description
    resource isolated function post api/v2/users/[int user_id]/password(string accept = "application/json") returns string|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/password`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        string response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # List password requirements
    #
    # + user_id - The id of the user
    # + return - Success response
    resource isolated function get api/v2/users/[int user_id]/password/requirements(string accept = "application/json") returns UserPasswordRequirementsResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/password/requirements`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        UserPasswordRequirementsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Show User Related Information
    #
    # + user_id - The id of the user
    # + return - Success response
    resource isolated function get api/v2/users/[int user_id]/related(string accept = "application/json") returns UserRelatedResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/related`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        UserRelatedResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Bulk Delete Sessions
    #
    # + user_id - The id of the user
    # + return - No Content
    resource isolated function delete api/v2/users/[int user_id]/sessions(string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/sessions`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Show Session
    #
    # + session_id - The ID of the session
    # + user_id - The id of the user
    # + return - Success response
    resource isolated function get api/v2/users/[int user_id]/sessions/[int session_id](string accept = "application/json") returns SessionResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/sessions/${getEncodedUri(session_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        SessionResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Delete Session
    #
    # + session_id - The ID of the session
    # + user_id - The id of the user
    # + return - No Content
    resource isolated function delete api/v2/users/[int user_id]/sessions/[int session_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/sessions/${getEncodedUri(session_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # List Ticket Skips
    #
    # + user_id - User ID of an agent
    # + sort_order - Sort order. Defaults to "asc"
    # + ticket_id - The ID of the ticket
    # + return - Success response
    resource isolated function get api/v2/users/[int user_id]/skips(string accept = "application/json", "asc"|"desc"? sort_order = ()) returns TicketSkipsResponse|error {
        string resourcePath = string `/api/v2/users/${getEncodedUri(user_id)}/skips`;
        map<anydata> queryParam = {"sort_order": sort_order};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketSkipsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Autocomplete Users
    #
    # + name - The name to search for the user.
    # + field_id - The id of a lookup relationship field.  The type of field is determined
    # by the `source` param
    # + 'source - If a `field_id` is provided, this specifies the type of the field.
    # For example, if the field is on a "zen:user", it references a field on a user
    # + return - Success response
    resource isolated function get api/v2/users/autocomplete(string name, string accept = "application/json", string? field_id = (), string? 'source = ()) returns UsersResponse|error {
        string resourcePath = string `/api/v2/users/autocomplete`;
        map<anydata> queryParam = {"name": name, "field_id": field_id, "source": 'source};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        UsersResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Count Users
    #
    # + role - Filters the results by role. Possible values are "end-user", "agent", or "admin"
    # + roles - Filters the results by more than one role using the format `role[]={role}&role[]={role}`
    # + permission_set - For custom roles which is available on the Enterprise plan and above. You can only filter by one role ID per request
    # + return - Success response
    resource isolated function get api/v2/users/count(string accept = "application/json", "end-user"|"agent"|"admin"? role = (), string? roles = (), int? permission_set = ()) returns CountResponse|error {
        string resourcePath = string `/api/v2/users/count`;
        map<anydata> queryParam = {"role": role, "roles": roles, "permission_set": permission_set};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        CountResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create Many Users
    #
    # + return - Success response
    resource isolated function post api/v2/users/create_many(UsersRequest payload) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/users/create_many`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        JobStatusResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Create Or Update User
    #
    # + return - Successful response, when user exits
    resource isolated function post api/v2/users/create_or_update(UserRequest payload) returns UserResponse|error {
        string resourcePath = string `/api/v2/users/create_or_update`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        UserResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Create Or Update Many Users
    #
    # + return - Success response
    resource isolated function post api/v2/users/create_or_update_many(UsersRequest payload) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/users/create_or_update_many`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        JobStatusResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Bulk Delete Users
    #
    # + ids - Id of the users to delete. Comma separated
    # + external_ids - External Id of the users to delete. Comma separated
    # + return - Success response
    resource isolated function delete api/v2/users/destroy_many(string accept = "application/json", string? ids = (), string? external_ids = ()) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/users/destroy_many`;
        map<anydata> queryParam = {"ids": ids, "external_ids": external_ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        JobStatusResponse response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Logout many users
    #
    # + ids - Accepts a comma-separated list of up to 100 user ids.
    # + return - Accepted response
    resource isolated function post api/v2/users/logout_many(string accept = "application/json", string? ids = ()) returns string|error {
        string resourcePath = string `/api/v2/users/logout_many`;
        map<anydata> queryParam = {"ids": ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        string response = check self.clientEp->post(resourcePath, request, httpHeaders);
        return response;
    }
    # Show Self
    #
    # + return - Success response
    resource isolated function get api/v2/users/me() returns CurrentUserResponse|error {
        string resourcePath = string `/api/v2/users/me`;
        CurrentUserResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Delete the Authenticated Session
    #
    # + return - No Content
    resource isolated function delete api/v2/users/me/logout() returns error? {
        string resourcePath = string `/api/v2/users/me/logout`;
        return self.clientEp->delete(resourcePath);
    }
    # Show the Currently Authenticated Session
    #
    # + return - Success response
    resource isolated function get api/v2/users/me/session() returns SessionResponse|error {
        string resourcePath = string `/api/v2/users/me/session`;
        SessionResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Renew the current session
    #
    # + return - Success response
    resource isolated function get api/v2/users/me/session/renew() returns RenewSessionResponse|error {
        string resourcePath = string `/api/v2/users/me/session/renew`;
        RenewSessionResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Request User Create
    #
    # + return - description
    resource isolated function post api/v2/users/request_create(UserRequest payload) returns string|error {
        string resourcePath = string `/api/v2/users/request_create`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        string response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Search Users
    #
    # + query - The `query` parameter supports the Zendesk search syntax for more advanced
    # user searches. It can specify a partial or full value of any
    # user property, including name, email address, notes, or phone. Example:
    # `query="jdoe"`.
    # See the [Search API](/api-reference/ticketing/ticket-management/search/).
    # + external_id - The `external_id` parameter does not support the search syntax. It only accepts ids.
    # + return - Success response
    resource isolated function get api/v2/users/search(string accept = "application/json", string? query = (), string? external_id = ()) returns UsersResponse|error {
        string resourcePath = string `/api/v2/users/search`;
        map<anydata> queryParam = {"query": query, "external_id": external_id};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        UsersResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Show Many Users
    #
    # + ids - Accepts a comma-separated list of up to 100 user ids.
    # + external_ids - Accepts a comma-separated list of up to 100 external ids.
    # + return - Success response
    resource isolated function get api/v2/users/show_many(string accept = "application/json", string? ids = (), string? external_ids = ()) returns UsersResponse|error {
        string resourcePath = string `/api/v2/users/show_many`;
        map<anydata> queryParam = {"ids": ids, "external_ids": external_ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        UsersResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Many Users
    #
    # + ids - Id of the users to update. Comma separated
    # + external_ids - External Id of the users to update. Comma separated
    # + return - Successful response
    resource isolated function put api/v2/users/update_many(Users_update_many_body payload, string accept = "application/json", string? ids = (), string? external_ids = ()) returns JobStatusResponse|error {
        string resourcePath = string `/api/v2/users/update_many`;
        map<anydata> queryParam = {"ids": ids, "external_ids": external_ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        JobStatusResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # List Views
    #
    # + access - Only views with given access. May be "personal", "shared", or "account"
    # + active - Only active views if true, inactive views if false
    # + group_id - Only views belonging to given group
    # + sort_by - Possible values are "alphabetical", "created_at", or "updated_at". Defaults to "position"
    # + sort_order - One of "asc" or "desc". Defaults to "asc" for alphabetical and position sort, "desc" for all others
    # + return - Success response
    resource isolated function get api/v2/views(string accept = "application/json", string? access = (), boolean? active = (), int? group_id = (), string? sort_by = (), string? sort_order = ()) returns ViewsResponse|error {
        string resourcePath = string `/api/v2/views`;
        map<anydata> queryParam = {"access": access, "active": active, "group_id": group_id, "sort_by": sort_by, "sort_order": sort_order};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ViewsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Create View
    #
    # + return - Success response
    resource isolated function post api/v2/views() returns ViewResponse|error {
        string resourcePath = string `/api/v2/views`;
        http:Request request = new;
        ViewResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show View
    #
    # + view_id - The ID of the view
    # + return - Success response
    resource isolated function get api/v2/views/[int view_id](string accept = "application/json") returns ViewResponse|error {
        string resourcePath = string `/api/v2/views/${getEncodedUri(view_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ViewResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update View
    #
    # + view_id - The ID of the view
    # + return - Success response
    resource isolated function put api/v2/views/[int view_id](string accept = "application/json") returns ViewResponse|error {
        string resourcePath = string `/api/v2/views/${getEncodedUri(view_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        ViewResponse response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete View
    #
    # + view_id - The ID of the view
    # + return - No Content response
    resource isolated function delete api/v2/views/[int view_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/views/${getEncodedUri(view_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Count Tickets in View
    #
    # + view_id - The ID of the view
    # + return - Success response
    resource isolated function get api/v2/views/[int view_id]/count(string accept = "application/json") returns ViewCountResponse|error {
        string resourcePath = string `/api/v2/views/${getEncodedUri(view_id)}/count`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ViewCountResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Execute View
    #
    # + view_id - The ID of the view
    # + sort_by - The ticket field used for sorting. This will either be a title or a custom field id.
    # + sort_order - The direction the tickets are sorted. May be one of 'asc' or 'desc'
    # + return - Success response
    resource isolated function get api/v2/views/[int view_id]/execute(string accept = "application/json", string? sort_by = (), string? sort_order = ()) returns ViewResponse|error {
        string resourcePath = string `/api/v2/views/${getEncodedUri(view_id)}/execute`;
        map<anydata> queryParam = {"sort_by": sort_by, "sort_order": sort_order};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ViewResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Export View
    #
    # + view_id - The ID of the view
    # + return - Success response
    resource isolated function get api/v2/views/[int view_id]/export(string accept = "application/json") returns ViewExportResponse|error {
        string resourcePath = string `/api/v2/views/${getEncodedUri(view_id)}/export`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ViewExportResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Tickets From a View
    #
    # + view_id - The ID of the view
    # + sort_by - Sort or group the tickets by a column in the [View columns](#view-columns) table. The `subject` and `submitter` columns are not supported
    # + sort_order - One of "asc" or "desc". Defaults to "asc" for alphabetical and position sort, "desc" for all others
    # + return - Success response
    resource isolated function get api/v2/views/[int view_id]/tickets(string accept = "application/json", string? sort_by = (), string? sort_order = ()) returns TicketsResponse|error {
        string resourcePath = string `/api/v2/views/${getEncodedUri(view_id)}/tickets`;
        map<anydata> queryParam = {"sort_by": sort_by, "sort_order": sort_order};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        TicketsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Active Views
    #
    # + access - Only views with given access. May be "personal", "shared", or "account"
    # + group_id - Only views belonging to given group
    # + sort_by - Possible values are "alphabetical", "created_at", or "updated_at". Defaults to "position"
    # + sort_order - One of "asc" or "desc". Defaults to "asc" for alphabetical and position sort, "desc" for all others
    # + return - Success response
    resource isolated function get api/v2/views/active(string accept = "application/json", string? access = (), int? group_id = (), string? sort_by = (), string? sort_order = ()) returns ViewsResponse|error {
        string resourcePath = string `/api/v2/views/active`;
        map<anydata> queryParam = {"access": access, "group_id": group_id, "sort_by": sort_by, "sort_order": sort_order};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ViewsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Views - Compact
    #
    # + return - Success response
    resource isolated function get api/v2/views/compact() returns ViewsResponse|error {
        string resourcePath = string `/api/v2/views/compact`;
        ViewsResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Count Views
    #
    # + return - Count of views
    resource isolated function get api/v2/views/count() returns ViewsCountResponse|error {
        string resourcePath = string `/api/v2/views/count`;
        ViewsCountResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Count Tickets in Views
    #
    # + ids - List of view's ids separated by commas.
    # + return - Success response
    resource isolated function get api/v2/views/count_many(string ids, string accept = "application/json") returns ViewCountsResponse|error {
        string resourcePath = string `/api/v2/views/count_many`;
        map<anydata> queryParam = {"ids": ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ViewCountsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Bulk Delete Views
    #
    # + ids - The IDs of the views to delete
    # + return - No Content response
    resource isolated function delete api/v2/views/destroy_many(string ids, string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/views/destroy_many`;
        map<anydata> queryParam = {"ids": ids};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Preview Views
    #
    # + return - Success response
    resource isolated function post api/v2/views/preview() returns ViewResponse|error {
        string resourcePath = string `/api/v2/views/preview`;
        http:Request request = new;
        ViewResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Preview Ticket Count
    #
    # + return - Success response
    resource isolated function post api/v2/views/preview/count() returns ViewCountResponse|error {
        string resourcePath = string `/api/v2/views/preview/count`;
        http:Request request = new;
        ViewCountResponse response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Search Views
    #
    # + query - Query string used to find all views with matching title
    # + access - Filter views by access. May be "personal", "shared", or "account"
    # + active - Filter by active views if true or inactive views if false
    # + group_id - Filter views by group
    # + sort_by - Possible values are "alphabetical", "created_at", "updated_at", and "position". If unspecified, the views are sorted by relevance
    # + sort_order - One of "asc" or "desc". Defaults to "asc" for alphabetical and position sort, "desc" for all others
    # + include - A sideload to include in the response. See [Sideloads](#sideloads-3)
    # + return - Success response
    resource isolated function get api/v2/views/search(string query, string accept = "application/json", string? access = (), boolean? active = (), int? group_id = (), string? sort_by = (), string? sort_order = (), string? include = ()) returns ViewsResponse|error {
        string resourcePath = string `/api/v2/views/search`;
        map<anydata> queryParam = {"query": query, "access": access, "active": active, "group_id": group_id, "sort_by": sort_by, "sort_order": sort_order, "include": include};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ViewsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # List Views By ID
    #
    # + ids - List of view's ids separated by commas.
    # + active - Only active views if true, inactive views if false
    # + return - Success response
    resource isolated function get api/v2/views/show_many(string ids, string accept = "application/json", boolean? active = ()) returns ViewsResponse|error {
        string resourcePath = string `/api/v2/views/show_many`;
        map<anydata> queryParam = {"ids": ids, "active": active};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        ViewsResponse response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Many Views
    #
    # + return - Success response
    resource isolated function put api/v2/views/update_many() returns ViewsResponse|error {
        string resourcePath = string `/api/v2/views/update_many`;
        http:Request request = new;
        ViewsResponse response = check self.clientEp->put(resourcePath, request);
        return response;
    }
    # List Workspaces
    #
    # + return - Success Response
    resource isolated function get api/v2/workspaces() returns WorkspaceResponse|error {
        string resourcePath = string `/api/v2/workspaces`;
        WorkspaceResponse response = check self.clientEp->get(resourcePath);
        return response;
    }
    # Create Workspace
    #
    # + return - Created workspace
    resource isolated function post api/v2/workspaces(V2_workspaces_body payload) returns Inline_response_201|error {
        string resourcePath = string `/api/v2/workspaces`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Inline_response_201 response = check self.clientEp->post(resourcePath, request);
        return response;
    }
    # Show Workspace
    #
    # + workspace_id - The id of the workspace
    # + return - Successful response
    resource isolated function get api/v2/workspaces/[int workspace_id](string accept = "application/json") returns Inline_response_201|error {
        string resourcePath = string `/api/v2/workspaces/${getEncodedUri(workspace_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        Inline_response_201 response = check self.clientEp->get(resourcePath, httpHeaders);
        return response;
    }
    # Update Workspace
    #
    # + workspace_id - The id of the workspace
    # + return - OK
    resource isolated function put api/v2/workspaces/[int workspace_id](Workspaces_workspace_id_body payload, string accept = "application/json") returns Inline_response_201|error {
        string resourcePath = string `/api/v2/workspaces/${getEncodedUri(workspace_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        Inline_response_201 response = check self.clientEp->put(resourcePath, request, httpHeaders);
        return response;
    }
    # Delete Workspace
    #
    # + workspace_id - The id of the workspace
    # + return - No Content
    resource isolated function delete api/v2/workspaces/[int workspace_id](string accept = "application/json") returns error? {
        string resourcePath = string `/api/v2/workspaces/${getEncodedUri(workspace_id)}`;
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }
    # Bulk Delete Workspaces
    #
    # + ids - The ids of the workspaces to delete
    # + return - Succesful response
    resource isolated function delete api/v2/workspaces/destroy_many(int[] ids, string accept = "application/json") returns string|error {
        string resourcePath = string `/api/v2/workspaces/destroy_many`;
        map<anydata> queryParam = {"ids": ids};
        map<Encoding> queryParamEncoding = {"ids": {style: FORM, explode: true}};
        resourcePath = resourcePath + check getPathForQueryParam(queryParam, queryParamEncoding);
        map<any> headerValues = {"Accept": accept};
        map<string|string[]> httpHeaders = getMapForHeaders(headerValues);
        string response = check self.clientEp->delete(resourcePath, headers = httpHeaders);
        return response;
    }
    # Reorder Workspaces
    #
    # + return - Succesful response
    resource isolated function put api/v2/workspaces/reorder(Workspaces_reorder_body payload) returns string|error {
        string resourcePath = string `/api/v2/workspaces/reorder`;
        http:Request request = new;
        json jsonBody = payload.toJson();
        request.setPayload(jsonBody, "application/json");
        string response = check self.clientEp->put(resourcePath, request);
        return response;
    }
}
